#!/usr/bin/env python3

import hashlib
import json

import itertools
from typing import Any

# --------------------------------------------------------------------------------------------------
# Constants
# --------------------------------------------------------------------------------------------------

MAX_NUM_RESOURCES_PER_TEMPLATE = 500

# --------------------------------------------------------------------------------------------------
# Combinations
# --------------------------------------------------------------------------------------------------

PRINCIPAL_TYPE = [
    'user',
    'role',
]

SAME_OR_CROSS_ACCOUNT = [
    'same_account',
    'x_account',
]

PRINCIPAL_POLICY_TYPE = [
    'inline',
    'managed',
    'group',  # IAM users only
]

AWS_SERVICE = [
    'dynamodb',
    'iam',  # assume-role
    'kms',
    's3',
    'sns',
    'sqs',
]

INCL_RESOURCE_POLICY = [
    'with_resource_policy',
    'sans_resource_policy',
]

DECISION = [
    'should_allow',
    'should_NOT_allow',
]

FEATURE = [
    'basic',
    # 'explicit_deny',
    # 'principal_tags',
    # 'resource_tags',
    # 'permission_boundary',
]

# --------------------------------------------------------------------------------------------------
# Types
# --------------------------------------------------------------------------------------------------

#
# This is really the CF resource, almost CDK-esque, has type, properties
#

class Resource():

    account: int
    logical_name: str
    resource_type: str
    properties: dict[str, Any]

    def __init__(self):
        self.properties = {}

    def as_json(self):
        return json.dumps({
            'Type': self.resource_type,
            'Properties': self.properties,
        })

class TestCase():
    _valid: bool
    name: str
    policy_type: str
    principal_type: str
    is_x_account: bool
    resource_service: str
    has_resource_policy: bool
    other_feature: str
    should_allow: bool

    def is_valid(self) -> bool:
        return self._valid

    def _logical_name(self, *components: str) -> str:
        return hashlib.md5(' '.join(components).encode('utf-8')).hexdigest()

    def action(self) -> str:
        return {
            's3': 's3:GetObject',
            'dynamodb': 'dynamodb:Scan',
            'iam': 'sts:AssumeRole',
            'kms': 'kms:Decrypt',
            'sns': 'sns:Publish',
            'sqs': 'sqs:ReceiveMessage',
        }[self.resource_service]

    def principal_policy(self) -> dict[str, Any]:
        return {
            'PolicyName': 'autogenerated',
            'PolicyDocument': {
                'Version': '2012-10-17',
                'Statement': [
                    {
                        'Action': self.action(),
                        'Effect': 'Deny' if self.other_feature == 'explicit_deny' else 'Allow',
                        'Resource': '',
                    },
                ],
            },
        }

    def principal(self) -> list[Resource]:
        resources = []

        # ------------------------------------------------------------------------------------------
        # Principal
        # ------------------------------------------------------------------------------------------
        
        principal = Resource()
        resources.append(principal)
        principal.account = 0  # principal account is always 0
        principal.logical_name = self._logical_name('principal', self.name)

        if self.principal_type == 'user':
            principal.resource_type = 'AWS::IAM::User'
        elif self.principal_type == 'role':
            principal.resource_type = 'AWS::IAM::Role'
        else:
            raise ValueError(f'unknown principal.resource_type: {principal.resource_type}')

        if self.policy_type == 'inline':
            principal.properties['Policies'] = [
                {
                    'PolicyName': 'autogenerated',
                    'PolicyDocument': {
                        'Version': 'FIXME',
                        'Statement': [
                            {
                                'Effect': '',
                                'Action': ''
                            },
                        ],
                    },
                },
            ]


        return resources

    def resource(self) -> list[Resource]:
        return []

    def gen(self) -> list[Resource]:
        return (
            self.principal()
            + self.resource()
        )

#
# Set of templates, we want as few templates per account as possible, so binpack resources into
# templates of 500 resources each until we run out of test cases
#

class Template():

    _resources: list[Resource]

    def __init__(self):
        self._resources = []

# --------------------------------------------------------------------------------------------------
# Calculate product
# --------------------------------------------------------------------------------------------------

def product():
    return itertools.product(
        PRINCIPAL_TYPE,
        SAME_OR_CROSS_ACCOUNT,
        PRINCIPAL_POLICY_TYPE,
        AWS_SERVICE,
        FEATURE,
        DECISION,
    )

def gen_test_cases() -> list[TestCase]:
    test_cases = []
    
    for principal_type in PRINCIPAL_TYPE:
        for same_or_cross_account in SAME_OR_CROSS_ACCOUNT:
            for policy_type in PRINCIPAL_POLICY_TYPE:
                for aws_service in AWS_SERVICE:
                    for feature in FEATURE:
                        for resource_policy in INCL_RESOURCE_POLICY:
                            for decision in DECISION:
                                tc = TestCase()
                                tc.name = ' '.join([
                                    principal_type,
                                    same_or_cross_account,
                                    policy_type,
                                    aws_service,
                                    feature,
                                    resource_policy,
                                    decision,
                                ])
                                tc.principal_type = principal_type
                                tc.is_x_account = same_or_cross_account == 'x_account'
                                tc.policy_type = policy_type
                                tc.resource_service = aws_service
                                tc.other_feature = feature
                                tc.has_resource_policy = resource_policy == 'with_resource_policy'
                                tc.should_allow = decision == 'should_allow'
                                test_cases.append(tc)
    return test_cases

def main():
    test_cases = gen_test_cases()
    print([t.name for t in test_cases])

if __name__ == '__main__':
    main()
