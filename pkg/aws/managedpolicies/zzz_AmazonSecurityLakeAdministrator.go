// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_AmazonSecurityLakeAdministrator = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "AllowActionsWithAnyResource", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"securitylake:*", "organizations:DescribeOrganization", "organizations:ListDelegatedServicesForAccount", "organizations:ListAccounts", "iam:ListRoles", "ram:GetResourceShareAssociations"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue(nil)}, policy.Statement{Sid: "AllowActionsWithAnyResourceViaSecurityLake", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateCrawler", "glue:StopCrawlerSchedule", "lambda:CreateEventSourceMapping", "lakeformation:GrantPermissions", "lakeformation:ListPermissions", "lakeformation:RegisterResource", "lakeformation:RevokePermissions", "lakeformation:GetDatalakeSettings", "events:ListConnections", "events:ListApiDestinations", "iam:GetRole", "iam:ListAttachedRolePolicies", "kms:DescribeKey"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowManagingSecurityLakeS3Buckets", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:CreateBucket", "s3:PutBucketPolicy", "s3:PutBucketPublicAccessBlock", "s3:PutBucketNotification", "s3:PutBucketTagging", "s3:PutEncryptionConfiguration", "s3:PutBucketVersioning", "s3:PutReplicationConfiguration", "s3:PutLifecycleConfiguration", "s3:ListBucket", "s3:PutObject", "s3:GetBucketNotification"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::aws-security-data-lake*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowLambdaCreateFunction", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:CreateFunction"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:SecurityLake_Glue_Partition_Updater_Lambda*", "arn:aws:lambda:*:*:function:AmazonSecurityLake*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowLambdaAddPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:AddPermission"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:SecurityLake_Glue_Partition_Updater_Lambda*", "arn:aws:lambda:*:*:function:AmazonSecurityLake*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": map[string]policy.ConditionValue{"lambda:Principal": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowGlueActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateDatabase", "glue:GetDatabase", "glue:CreateTable", "glue:GetTable"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/amazon_security_lake_glue_db*", "arn:aws:glue:*:*:table/amazon_security_lake_glue_db*/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowEventBridgeActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"events:PutTargets", "events:PutRule", "events:DescribeRule", "events:CreateApiDestination", "events:CreateConnection", "events:UpdateConnection", "events:UpdateApiDestination", "events:DeleteConnection", "events:DeleteApiDestination", "events:ListTargetsByRule", "events:RemoveTargets", "events:DeleteRule"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:events:*:*:rule/AmazonSecurityLake*", "arn:aws:events:*:*:rule/SecurityLake*", "arn:aws:events:*:*:api-destination/AmazonSecurityLake*", "arn:aws:events:*:*:connection/AmazonSecurityLake*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowSQSActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sqs:CreateQueue", "sqs:SetQueueAttributes", "sqs:GetQueueURL", "sqs:AddPermission", "sqs:GetQueueAttributes", "sqs:DeleteQueue"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sqs:*:*:SecurityLake*", "arn:aws:sqs:*:*:AmazonSecurityLake*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowKmsCmkGrantForSecurityLake", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:CreateGrant"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAllValues:StringEquals": map[string]policy.ConditionValue{"kms:GrantOperations": []interface{}{"GenerateDataKey", "RetireGrant", "Decrypt"}}, "ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"kms:EncryptionContext:aws:s3:arn": "arn:aws:s3:::aws-security-data-lake*"}}}, policy.Statement{Sid: "AllowEnablingQueryBasedSubscribers", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ram:CreateResourceShare", "ram:AssociateResourceShare"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringLikeIfExists": map[string]policy.ConditionValue{"ram:ResourceArn": []interface{}{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/amazon_security_lake_glue_db*", "arn:aws:glue:*:*:table/amazon_security_lake_glue_db*/*"}}}}, policy.Statement{Sid: "AllowConfiguringQueryBasedSubscribers", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ram:UpdateResourceShare", "ram:GetResourceShares", "ram:DisassociateResourceShare", "ram:DeleteResourceShare"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"ram:ResourceShareName": "LakeFormation*"}}}, policy.Statement{Sid: "AllowConfiguringCredentialsForSubscriberNotification", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:CreateSecret", "secretsmanager:GetSecretValue", "secretsmanager:PutSecretValue"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:secretsmanager:*:*:secret:events!connection/AmazonSecurityLake-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowPassRoleForUpdatingGluePartitionsSecLakeArn", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeMetaStoreManager", "arn:aws:iam::*:role/service-role/AmazonSecurityLakeMetaStoreManagerV2"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"StringEquals": map[string]policy.ConditionValue{"iam:PassedToService": "lambda.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"iam:AssociatedResourceARN": "arn:aws:securitylake:*:*:data-lake/default"}}}, policy.Statement{Sid: "AllowPassRoleForUpdatingGluePartitionsLambdaArn", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeMetaStoreManager", "arn:aws:iam::*:role/service-role/AmazonSecurityLakeMetaStoreManagerV2"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": map[string]policy.ConditionValue{"iam:PassedToService": "lambda.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"iam:AssociatedResourceARN": []interface{}{"arn:aws:lambda:*:*:function:SecurityLake_Glue_Partition_Updater_Lambda*", "arn:aws:lambda:*:*:function:AmazonSecurityLake*"}}}}, policy.Statement{Sid: "AllowPassRoleForCrossRegionReplicationSecLakeArn", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeS3ReplicationRole"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"StringEquals": map[string]policy.ConditionValue{"iam:PassedToService": "s3.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"iam:AssociatedResourceARN": "arn:aws:securitylake:*:*:data-lake/default"}}}, policy.Statement{Sid: "AllowPassRoleForCrossRegionReplicationS3Arn", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeS3ReplicationRole"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": map[string]policy.ConditionValue{"iam:PassedToService": "s3.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"iam:AssociatedResourceARN": "arn:aws:s3:::aws-security-data-lake*"}}}, policy.Statement{Sid: "AllowPassRoleForCustomSourceCrawlerSecLakeArn", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeCustomDataGlueCrawler*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"StringEquals": map[string]policy.ConditionValue{"iam:PassedToService": "glue.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"iam:AssociatedResourceARN": "arn:aws:securitylake:*:*:data-lake/default"}}}, policy.Statement{Sid: "AllowPassRoleForCustomSourceCrawlerGlueArn", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeCustomDataGlueCrawler*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": map[string]policy.ConditionValue{"iam:PassedToService": "glue.amazonaws.com"}}}, policy.Statement{Sid: "AllowPassRoleForSubscriberNotificationSecLakeArn", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeSubscriberEventBridge"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"StringEquals": map[string]policy.ConditionValue{"iam:PassedToService": "events.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"iam:AssociatedResourceARN": "arn:aws:securitylake:*:*:subscriber/*"}}}, policy.Statement{Sid: "AllowPassRoleForSubscriberNotificationEventsArn", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeSubscriberEventBridge"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": map[string]policy.ConditionValue{"iam:PassedToService": "events.amazonaws.com"}, "StringLike": map[string]policy.ConditionValue{"iam:AssociatedResourceARN": "arn:aws:events:*:*:rule/AmazonSecurityLake*"}}}, policy.Statement{Sid: "AllowOnboardingToSecurityLakeDependencies", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:CreateServiceLinkedRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/aws-service-role/securitylake.amazonaws.com/AWSServiceRoleForSecurityLake", "arn:aws:iam::*:role/aws-service-role/lakeformation.amazonaws.com/AWSServiceRoleForLakeFormationDataAccess", "arn:aws:iam::*:role/aws-service-role/apidestinations.events.amazonaws.com/AWSServiceRoleForAmazonEventBridgeApiDestinations"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"StringLike": map[string]policy.ConditionValue{"iam:AWSServiceName": []interface{}{"securitylake.amazonaws.com", "lakeformation.amazonaws.com", "apidestinations.events.amazonaws.com"}}}}, policy.Statement{Sid: "AllowRolePolicyActionsforSubscibersandSources", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:CreateRole", "iam:PutRolePolicy", "iam:DeleteRolePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonSecurityLake*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": map[string]policy.ConditionValue{"iam:PermissionsBoundary": "arn:aws:iam::aws:policy/AmazonSecurityLakePermissionsBoundary"}}}, policy.Statement{Sid: "AllowRegisterS3LocationInLakeFormation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PutRolePolicy", "iam:GetRolePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/aws-service-role/lakeformation.amazonaws.com/AWSServiceRoleForLakeFormationDataAccess"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowIAMActionsByResource", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:ListRolePolicies", "iam:DeleteRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonSecurityLake*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAnyValue:StringEquals": map[string]policy.ConditionValue{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "S3ReadAccessToSecurityLakes", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:Get*", "s3:List*"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::aws-security-data-lake-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue(nil)}, policy.Statement{Sid: "S3ReadAccessToSecurityLakeMetastoreObject", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetObject", "s3:GetObjectVersion"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::security-lake-meta-store-manager-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue(nil)}, policy.Statement{Sid: "S3ResourcelessReadOnly", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetAccountPublicAccessBlock", "s3:ListAccessPoints", "s3:ListAllMyBuckets"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue(nil)}}}
