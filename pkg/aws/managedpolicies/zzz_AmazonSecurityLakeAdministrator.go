// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_AmazonSecurityLakeAdministrator = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "AllowActionsWithAnyResource", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"securitylake:*", "organizations:DescribeOrganization", "organizations:ListDelegatedServicesForAccount", "organizations:ListAccounts", "iam:ListRoles", "ram:GetResourceShareAssociations"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "AllowActionsWithAnyResourceViaSecurityLake", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"glue:CreateCrawler", "glue:StopCrawlerSchedule", "lambda:CreateEventSourceMapping", "lakeformation:GrantPermissions", "lakeformation:ListPermissions", "lakeformation:RegisterResource", "lakeformation:RevokePermissions", "lakeformation:GetDatalakeSettings", "events:ListConnections", "events:ListApiDestinations", "iam:GetRole", "iam:ListAttachedRolePolicies", "kms:DescribeKey"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowManagingSecurityLakeS3Buckets", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"s3:CreateBucket", "s3:PutBucketPolicy", "s3:PutBucketPublicAccessBlock", "s3:PutBucketNotification", "s3:PutBucketTagging", "s3:PutEncryptionConfiguration", "s3:PutBucketVersioning", "s3:PutReplicationConfiguration", "s3:PutLifecycleConfiguration", "s3:ListBucket", "s3:PutObject", "s3:GetBucketNotification"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:s3:::aws-security-data-lake*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowLambdaCreateFunction", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"lambda:CreateFunction"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:lambda:*:*:function:SecurityLake_Glue_Partition_Updater_Lambda*", "arn:aws:lambda:*:*:function:AmazonSecurityLake*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowLambdaAddPermission", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"lambda:AddPermission"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:lambda:*:*:function:SecurityLake_Glue_Partition_Updater_Lambda*", "arn:aws:lambda:*:*:function:AmazonSecurityLake*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": policy.Condition{"lambda:Principal": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowGlueActions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"glue:CreateDatabase", "glue:GetDatabase", "glue:CreateTable", "glue:GetTable"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/amazon_security_lake_glue_db*", "arn:aws:glue:*:*:table/amazon_security_lake_glue_db*/*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowEventBridgeActions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"events:PutTargets", "events:PutRule", "events:DescribeRule", "events:CreateApiDestination", "events:CreateConnection", "events:UpdateConnection", "events:UpdateApiDestination", "events:DeleteConnection", "events:DeleteApiDestination", "events:ListTargetsByRule", "events:RemoveTargets", "events:DeleteRule"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:events:*:*:rule/AmazonSecurityLake*", "arn:aws:events:*:*:rule/SecurityLake*", "arn:aws:events:*:*:api-destination/AmazonSecurityLake*", "arn:aws:events:*:*:connection/AmazonSecurityLake*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowSQSActions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"sqs:CreateQueue", "sqs:SetQueueAttributes", "sqs:GetQueueURL", "sqs:AddPermission", "sqs:GetQueueAttributes", "sqs:DeleteQueue"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:sqs:*:*:SecurityLake*", "arn:aws:sqs:*:*:AmazonSecurityLake*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowKmsCmkGrantForSecurityLake", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"kms:CreateGrant"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:kms:*:*:key/*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAllValues:StringEquals": policy.Condition{"kms:GrantOperations": []interface{}{"GenerateDataKey", "RetireGrant", "Decrypt"}}, "ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringLike": policy.Condition{"kms:EncryptionContext:aws:s3:arn": "arn:aws:s3:::aws-security-data-lake*"}}}, policy.Statement{Sid: "AllowEnablingQueryBasedSubscribers", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"ram:CreateResourceShare", "ram:AssociateResourceShare"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringLikeIfExists": policy.Condition{"ram:ResourceArn": []interface{}{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/amazon_security_lake_glue_db*", "arn:aws:glue:*:*:table/amazon_security_lake_glue_db*/*"}}}}, policy.Statement{Sid: "AllowConfiguringQueryBasedSubscribers", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"ram:UpdateResourceShare", "ram:GetResourceShares", "ram:DisassociateResourceShare", "ram:DeleteResourceShare"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringLike": policy.Condition{"ram:ResourceShareName": "LakeFormation*"}}}, policy.Statement{Sid: "AllowConfiguringCredentialsForSubscriberNotification", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"secretsmanager:CreateSecret", "secretsmanager:GetSecretValue", "secretsmanager:PutSecretValue"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:secretsmanager:*:*:secret:events!connection/AmazonSecurityLake-*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowPassRoleForUpdatingGluePartitionsSecLakeArn", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeMetaStoreManager", "arn:aws:iam::*:role/service-role/AmazonSecurityLakeMetaStoreManagerV2"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"iam:PassedToService": "lambda.amazonaws.com"}, "StringLike": policy.Condition{"iam:AssociatedResourceARN": "arn:aws:securitylake:*:*:data-lake/default"}}}, policy.Statement{Sid: "AllowPassRoleForUpdatingGluePartitionsLambdaArn", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeMetaStoreManager", "arn:aws:iam::*:role/service-role/AmazonSecurityLakeMetaStoreManagerV2"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": policy.Condition{"iam:PassedToService": "lambda.amazonaws.com"}, "StringLike": policy.Condition{"iam:AssociatedResourceARN": []interface{}{"arn:aws:lambda:*:*:function:SecurityLake_Glue_Partition_Updater_Lambda*", "arn:aws:lambda:*:*:function:AmazonSecurityLake*"}}}}, policy.Statement{Sid: "AllowPassRoleForCrossRegionReplicationSecLakeArn", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeS3ReplicationRole"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"iam:PassedToService": "s3.amazonaws.com"}, "StringLike": policy.Condition{"iam:AssociatedResourceARN": "arn:aws:securitylake:*:*:data-lake/default"}}}, policy.Statement{Sid: "AllowPassRoleForCrossRegionReplicationS3Arn", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeS3ReplicationRole"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": policy.Condition{"iam:PassedToService": "s3.amazonaws.com"}, "StringLike": policy.Condition{"iam:AssociatedResourceARN": "arn:aws:s3:::aws-security-data-lake*"}}}, policy.Statement{Sid: "AllowPassRoleForCustomSourceCrawlerSecLakeArn", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeCustomDataGlueCrawler*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"iam:PassedToService": "glue.amazonaws.com"}, "StringLike": policy.Condition{"iam:AssociatedResourceARN": "arn:aws:securitylake:*:*:data-lake/default"}}}, policy.Statement{Sid: "AllowPassRoleForCustomSourceCrawlerGlueArn", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeCustomDataGlueCrawler*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": policy.Condition{"iam:PassedToService": "glue.amazonaws.com"}}}, policy.Statement{Sid: "AllowPassRoleForSubscriberNotificationSecLakeArn", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeSubscriberEventBridge"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"iam:PassedToService": "events.amazonaws.com"}, "StringLike": policy.Condition{"iam:AssociatedResourceARN": "arn:aws:securitylake:*:*:subscriber/*"}}}, policy.Statement{Sid: "AllowPassRoleForSubscriberNotificationEventsArn", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/service-role/AmazonSecurityLakeSubscriberEventBridge"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": policy.Condition{"iam:PassedToService": "events.amazonaws.com"}, "StringLike": policy.Condition{"iam:AssociatedResourceARN": "arn:aws:events:*:*:rule/AmazonSecurityLake*"}}}, policy.Statement{Sid: "AllowOnboardingToSecurityLakeDependencies", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:CreateServiceLinkedRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/aws-service-role/securitylake.amazonaws.com/AWSServiceRoleForSecurityLake", "arn:aws:iam::*:role/aws-service-role/lakeformation.amazonaws.com/AWSServiceRoleForLakeFormationDataAccess", "arn:aws:iam::*:role/aws-service-role/apidestinations.events.amazonaws.com/AWSServiceRoleForAmazonEventBridgeApiDestinations"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringLike": policy.Condition{"iam:AWSServiceName": []interface{}{"securitylake.amazonaws.com", "lakeformation.amazonaws.com", "apidestinations.events.amazonaws.com"}}}}, policy.Statement{Sid: "AllowRolePolicyActionsforSubscibersandSources", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:CreateRole", "iam:PutRolePolicy", "iam:DeleteRolePolicy"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/AmazonSecurityLake*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}, "StringEquals": policy.Condition{"iam:PermissionsBoundary": "arn:aws:iam::aws:policy/AmazonSecurityLakePermissionsBoundary"}}}, policy.Statement{Sid: "AllowRegisterS3LocationInLakeFormation", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PutRolePolicy", "iam:GetRolePolicy"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/aws-service-role/lakeformation.amazonaws.com/AWSServiceRoleForLakeFormationDataAccess"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "AllowIAMActionsByResource", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:ListRolePolicies", "iam:DeleteRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/AmazonSecurityLake*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": "securitylake.amazonaws.com"}}}, policy.Statement{Sid: "S3ReadAccessToSecurityLakes", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"s3:Get*", "s3:List*"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:s3:::aws-security-data-lake-*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "S3ReadAccessToSecurityLakeMetastoreObject", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"s3:GetObject", "s3:GetObjectVersion"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:s3:::security-lake-meta-store-manager-*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "S3ResourcelessReadOnly", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"s3:GetAccountPublicAccessBlock", "s3:ListAccessPoints", "s3:ListAllMyBuckets"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock(nil)}}}
