// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_SageMakerStudioProjectProvisioningRolePolicy = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "CloudFormationStackCreationAndTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudformation:CreateStack", "cloudformation:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:cloudformation:*:*:stack/DataZone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CloudFormationStackManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudformation:DescribeStacks", "cloudformation:DescribeStackEvents", "cloudformation:UpdateStack"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:cloudformation:*:*:stack/DataZone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CloudFormationStackDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudformation:DeleteStack"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:cloudformation:*:*:stack/DataZone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CloudFormationListStacks", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudformation:DescribeStacks"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:cloudformation:*:*:stack/DataZone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "LakeFormationPermissionsForDataLakeValidation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lakeformation:GetDataLakeSettings", "lakeformation:PutDataLakeSettings", "lakeformation:RevokePermissions", "lakeformation:ListPermissions"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "LakeFormationPermissionsForDataLakeResourceGrant", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lakeformation:RegisterResource", "lakeformation:DeregisterResource", "lakeformation:GrantPermissions", "lakeformation:ListResources"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "PermissionsToGetBlueprintTemplates", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetObject"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}, "StringNotEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CodeCommitCreationAndTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"codecommit:CreateRepository", "codecommit:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:codecommit:*:*:datazone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CodeCommitDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"codecommit:DeleteRepository"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:codecommit:*:*:datazone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CodeCommitAccess", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"codecommit:GetBranch", "codecommit:CreateCommit", "codecommit:GetRepository", "codecommit:GetFile"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:codecommit:*:*:datazone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CodeCommitListRepositories", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"codecommit:ListRepositories"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GetIAMRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:GetRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone*", "arn:aws:iam::*:role/AmazonBedrockExecution*", "arn:aws:iam::*:role/BedrockStudio*", "arn:aws:iam::*:role/AmazonBedrockConsumptionRole*", "arn:aws:iam::*:role/AmazonBedrockEvaluation*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IAMRoleAndPolicyManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:CreateRole", "iam:DetachRolePolicy", "iam:DeleteRolePolicy", "iam:AttachRolePolicy", "iam:PutRolePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone*", "arn:aws:iam::*:role/AmazonBedrockExecution*", "arn:aws:iam::*:role/BedrockStudio*", "arn:aws:iam::*:role/AmazonBedrockConsumptionRole*", "arn:aws:iam::*:role/AmazonBedrockEvaluation*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PermissionsBoundary": policy.Value{"arn:aws:iam::aws:policy/SageMakerStudioProjectUserRolePermissionsBoundary"}}}}, policy.Statement{Sid: "IAMRoleAndPolicyManagementFromDataZone", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:DeleteRolePolicy", "iam:PutRolePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PermissionsBoundary": policy.Value{"arn:aws:iam::aws:policy/SageMakerStudioProjectUserRolePermissionsBoundary"}}}}, policy.Statement{Sid: "IAMRoleTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:TagRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_usr_role_*", "arn:aws:iam::*:role/datazone-partner-apps-*", "arn:aws:iam::*:role/datazone_redshift_serverless_admin_role_*", "arn:aws:iam::*:role/AmazonBedrockExecution*", "arn:aws:iam::*:role/BedrockStudio*", "arn:aws:iam::*:role/AmazonBedrockConsumptionRole*", "arn:aws:iam::*:role/AmazonBedrockEvaluation*", "arn:aws:iam::*:role/SageMakerStudioQueryExecutionRole"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "AmazonBedrockManaged", "RedshiftDb*", "EnableAmazonBedrockIDEPermissions", "EnableGlueWorkloadsPermissions", "EnableSageMakerMLWorkloadsPermissions", "DomainBucketName", "KmsKeyId", "LogGroupName", "RoleName", "vpcArn", "VpcId", "CreatedForUseWithSageMakerStudio", "SageMakerStudioQueryExecutionRole"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IAMRoleTaggingForRedshift", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:TagRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_usr_role_*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"RedshiftDb*"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IAMRoleTaggingForEmr", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:TagRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_emr_service_role_*", "arn:aws:iam::*:role/datazone_emr_ec2_instance_role_*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "DataZone*", "for-use-with-amazon-emr-managed-policies", "DomainBucketName"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IamManageRoles", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:DeleteRole", "iam:ListRolePolicies", "iam:GetRolePolicy", "iam:ListAttachedRolePolicies"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone*", "arn:aws:iam::*:role/AmazonBedrockExecution*", "arn:aws:iam::*:role/BedrockStudio*", "arn:aws:iam::*:role/AmazonBedrockConsumptionRole*", "arn:aws:iam::*:role/AmazonBedrockEvaluation*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IamManageRolesFromDataZone", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:GetRole", "iam:UpdateAssumeRolePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_usr_role_*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IamAttachPolicyFromService", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:AttachRolePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PermissionsBoundary": policy.Value{"arn:aws:iam::aws:policy/SageMakerStudioProjectUserRolePermissionsBoundary"}}}}, policy.Statement{Sid: "IamDetachPolicyFromService", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:DetachRolePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IAMPolicyManagementFromService", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:DeletePolicy", "iam:CreatePolicy", "iam:ListPolicies", "iam:GetPolicy", "iam:GetPolicyVersion", "iam:CreatePolicyVersion", "iam:ListPolicyVersions", "iam:DeletePolicyVersion"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:policy/datazone*", "arn:aws:iam::*:policy/connector-manage-access-policy*", "arn:aws:iam::*:policy/SageMakerStudioQueryExecutionRolePolicy"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IAMPolicyManagementWithoutRequiredResources", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:ListPolicies"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueConnectionTypeUnrestrictedAccess", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:ListConnectionTypes", "glue:DescribeConnectionType"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "IAMInstanceProfileManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:GetInstanceProfile", "iam:CreateInstanceProfile", "iam:AddRoleToInstanceProfile", "iam:RemoveRoleFromInstanceProfile", "iam:DeleteInstanceProfile"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:instance-profile/datazone_emr_ec2_instance_profile_*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IamPassRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_usr_role_*", "arn:aws:iam::*:role/SageMakerStudioQueryExecutionRole"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com", "glue.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"glue.amazonaws.com", "lakeformation.amazonaws.com", "redshift-serverless.amazonaws.com", "redshift.amazonaws.com", "emr-serverless.amazonaws.com", "airflow.amazonaws.com"}}}}, policy.Statement{Sid: "IamPassRoleFromDataZone", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_usr_role_*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"sagemaker.amazonaws.com", "redshift-serverless.amazonaws.com"}}}}, policy.Statement{Sid: "IamPassRoleForGlueCatalog", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_usr_role_*", "arn:aws:iam::*:role/SageMakerStudioQueryExecutionRole"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"glue.amazonaws.com", "lakeformation.amazonaws.com"}}}}, policy.Statement{Sid: "IamPassRoleForEmrServiceRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_emr_service_role_*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"elasticmapreduce.amazonaws.com"}}}}, policy.Statement{Sid: "IamPassRoleForEmrInstanceRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_emr_ec2_instance_role_*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"ec2.amazonaws.com"}}}}, policy.Statement{Sid: "IamPassRoleToBedrock", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonBedrockExecution*", "arn:aws:iam::*:role/BedrockStudio*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"bedrock.amazonaws.com"}}}}, policy.Statement{Sid: "IamPassRoleToLambda", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonBedrockExecution*", "arn:aws:iam::*:role/BedrockStudio*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"lambda.amazonaws.com"}}}}, policy.Statement{Sid: "IamCreateServiceLinkedRoleForAoss", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:CreateServiceLinkedRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/aws-service-role/observability.aoss.amazonaws.com/AWSServiceRoleForAmazonOpenSearchServerless"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:AWSServiceName": policy.Value{"observability.aoss.amazonaws.com"}}}}, policy.Statement{Sid: "GlueDefaultDatabaseCreation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateDatabase", "glue:GetDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:database/default", "arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueDatabaseCreationFromCloudFormation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueGetDatabaseForTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueDatabaseDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:DeleteDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "TagGlueResources", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*"}}, "Null": map[string]policy.Value{"aws:RequestTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GetGlueConnectionToAllowTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetConnection"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:connection/datazone-glue-network-connection-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueConnectionCreateAndDelete", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateConnection", "glue:DeleteConnection"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:connection/datazone-glue-network-connection-*", "arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "FederatedDataGlueConnectionPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:PassConnection", "glue:GetConnections", "glue:GetTags"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:connection/*", "arn:aws:glue:*:*:catalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}}}, policy.Statement{Sid: "FederatedDataAthenaConnectionPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"athena:CreateDataCatalog"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:athena:*:*:datacatalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}}}, policy.Statement{Sid: "FederatedDataGetConnectionPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetConnection"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:connection/*", "arn:aws:glue:*:*:catalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "FederatedDataConnectionTaggingPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"athena:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:athena:*:*:datacatalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "federated_athena*"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}}}, policy.Statement{Sid: "FederatedDataConnectionGlueCreateConnection", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateConnection"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:connection/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:RequestTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "FederatedDataConnectionGlueManageConnection", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:DeleteConnection", "glue:UpdateConnection"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:connection/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "FederatedDataConnectionGlueManageConnectionOnCatalog", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:DeleteConnection", "glue:UpdateConnection"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "FederatedDBAthenaServerlessPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"serverlessrepo:GetCloudFormationTemplate", "serverlessrepo:CreateCloudFormationTemplate"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:serverlessrepo:*:*:applications/Athena*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "FederatedDBECRPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"imagebuilder:GetComponent", "imagebuilder:GetContainerRecipe", "ecr:GetAuthorizationToken", "ecr:BatchGetImage", "ecr:BatchCheckLayerAvailability", "ecr:GetDownloadUrlForLayer"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ecr:*:*:repository/athena-federation-repository*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"lambda.amazonaws.com"}}}}, policy.Statement{Sid: "FederatedDBAthenaCFNPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudformation:CreateChangeSet", "cloudformation:DeleteChangeSet"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:cloudformation:*:*:transform/Serverless*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"cloudformation.amazonaws.com"}}}}, policy.Statement{Sid: "FederatedDBAthenaLambdaPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:CreateFunction", "lambda:DeleteFunction"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:athenafederatedcatalog*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "FederatedDBAthenaGetFunctionLambdaPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:GetFunction"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:athenafederatedcatalog*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"athena.amazonaws.com", "cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "FederatedDBAthenaLambdaTaggingPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:athenafederatedcatalog*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "aws:cloudformation:*", "federated_athena*", "lambda:createdBy"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "FederatedDBAthenaS3Permission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetObject"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::awsserverlessrepo*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringLike": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"lambda.amazonaws.com"}}}}, policy.Statement{Sid: "FederatedDBGlueS3Permission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:ListBucket"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"s3:prefix": policy.Value{"true"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"glue.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "FederatedDBAthenaCommonPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudformation:CreateStack", "cloudformation:DeleteStack", "cloudformation:DescribeStacks"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:cloudformation:*:*:stack/athenafederatedcatalog*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/federated_athena_datacatalog": policy.Value{"false"}}}}, policy.Statement{Sid: "DataCatalogAccessForFederatedDatabase", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"athena:DeleteDataCatalog", "athena:GetDataCatalog", "athena:UpdateDataCatalog"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:athena:*:*:datacatalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IamPassProjectRoleToLambdaForFederatedDataConnection", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone_usr_role_*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"lambda.amazonaws.com"}}}}, policy.Statement{Sid: "IamGetRoleProvisioningRoleForFederatedDataConnection", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:GetRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/SageMakerStudioQueryExecutionRole"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueCatalogCreation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateCatalog"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:catalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:RequestTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueCatalogManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetCatalog", "glue:GetCatalogs", "glue:UpdateCatalog", "glue:DeleteCatalog", "glue:GetDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:catalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "RedShiftPermissionsForGlueCatalogs", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:CreateNamespace", "redshift-serverless:CreateWorkgroup", "redshift-serverless:DeleteNamespace", "redshift-serverless:DeleteWorkgroup", "redshift-serverless:ListTagsForResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift-serverless:*:*:namespace/*", "arn:aws:redshift-serverless:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "RedShiftDataSharePermissionsForGlueCatalogs", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift:AssociateDataShareConsumer", "redshift:AuthorizeDataShare"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift:*:*:datashare:*/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAnyValue:StringLike": map[string]policy.Value{"aws:CalledVia": policy.Value{"redshift-serverless.amazonaws.com", "glue.amazonaws.com"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "RedShiftStagingBucketCreation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:CreateBucket", "s3:DeleteBucket", "s3:PutBucketPolicy", "s3:PutEncryptionConfiguration", "s3:PutLifecycleConfiguration", "s3:PutBucketVersioning", "s3:PutBucketTagging"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::redshift-staging-bucket-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "RedshiftServerlessTaggingForGlueCatalog", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift-serverless:*:*:namespace/*", "arn:aws:redshift-serverless:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*"}}, "Null": map[string]policy.Value{"aws:RequestTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SecurityGroupCreation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateSecurityGroup"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:security-group/*", "arn:aws:ec2:*:*:vpc/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:TagKeys": policy.Value{"true"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SecurityGroupAuthorize", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:AuthorizeSecurityGroupEgress", "ec2:AuthorizeSecurityGroupIngress"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:security-group/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SecurityGroupManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:DeleteSecurityGroup", "ec2:RevokeSecurityGroupEgress", "ec2:RevokeSecurityGroupIngress"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:security-group/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SecurityGroupIngressRevokeForEMR", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:RevokeSecurityGroupIngress"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:security-group/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}}}, policy.Statement{Sid: "EC2ResourceTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateTags"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:security-group/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "for-use-with-amazon-emr-managed-policies", "aws:cloudformation:*"}}, "Null": map[string]policy.Value{"aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "DescribeNetworksPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:DescribeVpcs", "ec2:DescribeSecurityGroups", "ec2:DescribeNatGateways", "ec2:DescribeRouteTables", "ec2:DescribeSubnets"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "DescribeLogGroups", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:DescribeLogGroups"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}}}, policy.Statement{Sid: "LogGroupCreation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:CreateLogGroup", "logs:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:logs:*:*:log-group:datazone-*", "arn:aws:logs:*:*:log-group:/aws/lambda/amazon-bedrock-ide-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "AmazonBedrockManaged"}}, "Null": map[string]policy.Value{"aws:RequestTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "LogGroupPutRetentionPolicy", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:PutRetentionPolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:logs:*:*:log-group:datazone-*", "arn:aws:logs:*:*:log-group:/aws/lambda/amazon-bedrock-ide-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageLogGroups", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:DeleteLogGroup", "logs:DeleteRetentionPolicy", "logs:GetDataProtectionPolicy", "logs:PutDataProtectionPolicy", "logs:DeleteDataProtectionPolicy", "logs:AssociateKmsKey", "logs:DisassociateKmsKey", "logs:ListTagsForResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:logs:*:*:log-group:datazone-*", "arn:aws:logs:*:*:log-group:/aws/lambda/amazon-bedrock-ide-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AthenaWorkgroupCreationAndTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"athena:CreateWorkGroup", "athena:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:athena:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AthenaWorkgroupDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"athena:DeleteWorkGroup", "athena:GetWorkGroup"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:athena:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "RedshiftServerlessCreationAndTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:CreateNamespace", "redshift-serverless:CreateWorkgroup", "redshift-serverless:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift-serverless:*:*:namespace/*", "arn:aws:redshift-serverless:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "RedshiftServerlessListTags", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:ListTagsForResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift-serverless:*:*:namespace/*", "arn:aws:redshift-serverless:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AllowSecretManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:CreateSecret", "secretsmanager:DeleteSecret", "secretsmanager:UpdateSecret"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:ResourceTag/CreatedBy": policy.Value{"false"}}}}, policy.Statement{Sid: "AllowDescribeSecretPerProject", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:DescribeSecret"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}}}, policy.Statement{Sid: "AllowDescribeSecretTaggedForAllProjects", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:DescribeSecret"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/for-use-with-all-datazone-projects": policy.Value{"true"}}}}, policy.Statement{Sid: "AllowSecretTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "CreatedBy"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:ResourceTag/CreatedBy": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}}}, policy.Statement{Sid: "ServiceLinkedRoleCreation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:CreateServiceLinkedRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/aws-service-role/redshift.amazonaws.com/AWSServiceRoleForRedshift", "arn:aws:iam::*:role/aws-service-role/sagemaker.amazonaws.com/AWSServiceRoleForAmazonSageMakerNotebooks", "arn:aws:iam::*:role/aws-service-role/ops.emr-serverless.amazonaws.com/AWSServiceRoleForAmazonEMRServerless", "arn:aws:iam::*:role/aws-service-role/airflow.amazonaws.com/AWSServiceRoleForAmazonMWAA", "arn:aws:iam::*:role/aws-service-role/elasticmapreduce.amazonaws.com/AWSServiceRoleForEMRCleanup"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "RedshiftServerlessCreationPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:ListNamespaces", "redshift-serverless:ListWorkgroups", "redshift:GetResourcePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}}}, policy.Statement{Sid: "EC2PermissionsForGlueCatalog", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:DescribeAccountAttributes", "ec2:DescribeAvailabilityZones"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "RedshiftServerlessCreateDatabaseRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-data:ExecuteStatement", "redshift:GetResourcePolicy", "redshift-serverless:GetCredentials"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift-serverless:*:*:namespace/*", "arn:aws:redshift-serverless:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "RedshiftDataDescribeStatement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-data:DescribeStatement", "redshift-data:GetStatementResult"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "RedshiftDatashareDescribe", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift:DescribeDataSharesForConsumer", "redshift:DescribeDataShares"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "RedshiftServerlessValidation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:GetNamespace", "redshift-serverless:GetWorkgroup"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift-serverless:*:*:namespace/*", "arn:aws:redshift-serverless:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "RedshiftServerlessManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:UpdateNamespace", "redshift-serverless:UpdateWorkgroup", "redshift-serverless:UntagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift-serverless:*:*:namespace/*", "arn:aws:redshift-serverless:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GetRandomPasswordForSecret", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:GetRandomPassword"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}}}, policy.Statement{Sid: "ManageSecretPermissionsForBedrockApp", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:DescribeSecret", "secretsmanager:CreateSecret", "secretsmanager:UpdateSecret", "secretsmanager:DeleteSecret", "secretsmanager:GetResourcePolicy", "secretsmanager:PutResourcePolicy", "secretsmanager:DeleteResourcePolicy", "secretsmanager:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:secretsmanager:*:*:secret:amazon-bedrock-ide/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManagedRedshiftAdminSecretPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:CreateSecret", "secretsmanager:RotateSecret", "secretsmanager:DescribeSecret", "secretsmanager:UpdateSecret", "secretsmanager:DeleteSecret"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:secretsmanager:*:*:secret:redshift!*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManagedRedshiftAdminSecretTaggingPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:secretsmanager:*:*:secret:redshift!*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"Redshift", "aws:secretsmanager:*", "aws:redshift-serverless:*", "AmazonDataZone*", "datazone.rs.workgroup"}}, "Null": map[string]policy.Value{"aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SageMakerDomainCreationAndTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:CreateDomain", "sagemaker:AddTags"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sagemaker:*:*:domain/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:RequestTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SageMakerDomainDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:DeleteDomain"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sagemaker:*:*:domain/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SageMakerDomainManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:ListDomains", "sagemaker:DescribeDomain"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}}}, policy.Statement{Sid: "SageMakerAppDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:DeleteApp"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sagemaker:*:*:app/*/*/jupyterlab/*", "arn:aws:sagemaker:*:*:app/*/*/JupyterLab/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SageMakerSpaceDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:DeleteSpace"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sagemaker:*:*:space/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SageMakerUserProfileDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:DeleteUserProfile"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sagemaker:*:*:user-profile/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "EMRServerlessApplicationCreationAndTagging", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"emr-serverless:CreateApplication", "emr-serverless:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:emr-serverless:*:*:*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*"}}, "Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}, "aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "EMRServerlessApplicationManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"emr-serverless:GetApplication", "emr-serverless:DeleteApplication"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:emr-serverless:*:*:/applications/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CreateNetworkInterfaceForEMRServerless", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateNetworkInterface"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:network-interface/*", "arn:aws:ec2:*:*:subnet/*", "arn:aws:ec2:*:*:security-group/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"ops.emr-serverless.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SageMakerMlflowTrackingServerCreation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:CreateMlflowTrackingServer", "sagemaker:AddTags"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sagemaker:*:*:mlflow-tracking-server/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:RequestTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "SageMakerMlflowTrackingServerDescribe", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:DescribeMlflowTrackingServer"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sagemaker:*:*:mlflow-tracking-server/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "SageMakerMlflowTrackingServerDeletion", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sagemaker:DeleteMlflowTrackingServer"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sagemaker:*:*:mlflow-tracking-server/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageAossAccessPoliciesForBedrock", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"aoss:GetAccessPolicy", "aoss:CreateAccessPolicy", "aoss:DeleteAccessPolicy", "aoss:UpdateAccessPolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}, "StringLikeIfExists": map[string]policy.Value{"aoss:collection": policy.Value{"bedrock-ide-*"}, "aoss:index": policy.Value{"bedrock-ide-*"}}}}, policy.Statement{Sid: "ManageAossSecurityPoliciesForBedrock", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"aoss:GetSecurityPolicy", "aoss:CreateSecurityPolicy", "aoss:DeleteSecurityPolicy", "aoss:UpdateSecurityPolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}, "StringLikeIfExists": map[string]policy.Value{"aoss:collection": policy.Value{"bedrock-ide-*"}}}}, policy.Statement{Sid: "GetAossCollectionsForBedrock", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"aoss:BatchGetCollection"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageAossCollectionsForBedrock", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"aoss:CreateCollection", "aoss:UpdateCollection", "aoss:DeleteCollection", "aoss:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GetBedrockCfnResourceDefinitionS3Permissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetObject", "s3:GetObjectVersion"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::*/dzd_*/*/genAI/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GetBedrockResources", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:GetAgent", "bedrock:GetKnowledgeBase", "bedrock:GetGuardrail", "bedrock:GetPrompt", "bedrock:GetFlow", "bedrock:GetFlowAlias", "bedrock:ListTagsForResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageBedrockResources", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:CreateAgent", "bedrock:UpdateAgent", "bedrock:PrepareAgent", "bedrock:DeleteAgent", "bedrock:ListAgentAliases", "bedrock:GetAgentAlias", "bedrock:CreateAgentAlias", "bedrock:UpdateAgentAlias", "bedrock:DeleteAgentAlias", "bedrock:ListAgentActionGroups", "bedrock:GetAgentActionGroup", "bedrock:CreateAgentActionGroup", "bedrock:UpdateAgentActionGroup", "bedrock:DeleteAgentActionGroup", "bedrock:ListAgentKnowledgeBases", "bedrock:GetAgentKnowledgeBase", "bedrock:AssociateAgentKnowledgeBase", "bedrock:DisassociateAgentKnowledgeBase", "bedrock:UpdateAgentKnowledgeBase", "bedrock:CreateKnowledgeBase", "bedrock:UpdateKnowledgeBase", "bedrock:DeleteKnowledgeBase", "bedrock:ListDataSources", "bedrock:GetDataSource", "bedrock:CreateDataSource", "bedrock:UpdateDataSource", "bedrock:DeleteDataSource", "bedrock:CreateGuardrail", "bedrock:UpdateGuardrail", "bedrock:DeleteGuardrail", "bedrock:CreateGuardrailVersion", "bedrock:CreatePrompt", "bedrock:UpdatePrompt", "bedrock:DeletePrompt", "bedrock:CreatePromptVersion", "bedrock:CreateFlow", "bedrock:UpdateFlow", "bedrock:PrepareFlow", "bedrock:DeleteFlow", "bedrock:ListFlowAliases", "bedrock:GetFlowAlias", "bedrock:CreateFlowAlias", "bedrock:UpdateFlowAlias", "bedrock:DeleteFlowAlias", "bedrock:ListFlowVersions", "bedrock:GetFlowVersion", "bedrock:CreateFlowVersion", "bedrock:DeleteFlowVersion", "bedrock:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "TagBedrockTestAliases", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:bedrock:*:*:agent-alias/*/TSTALIASID", "arn:aws:bedrock:*:*:flow/*/alias/TSTALIASID"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:RequestTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ListBedrockEvaluationJobsFromServicePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:ListEvaluationJobs"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "ManageBedrockEvaluationJobsFromServicePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:BatchDeleteEvaluationJob"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "CreateFunctionPermissionsForBedrockApp", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:CreateFunction", "lambda:InvokeFunction", "lambda:DeleteFunction", "lambda:UpdateFunctionCode", "lambda:GetFunctionConfiguration", "lambda:UpdateFunctionConfiguration", "lambda:ListVersionsByFunction", "lambda:PublishVersion", "lambda:GetPolicy", "lambda:AddPermission", "lambda:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:amazon-bedrock-ide-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageFunctionPermissionsForBedrockApp", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:GetFunction", "lambda:ListTags", "lambda:RemovePermission"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:amazon-bedrock-ide-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "EMRSecurityConfigurationManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"elasticmapreduce:CreateSecurityConfiguration", "elasticmapreduce:DeleteSecurityConfiguration"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}}}, policy.Statement{Sid: "EMRClusterManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"elasticmapreduce:AddJobFlowSteps", "elasticmapreduce:AddTags", "elasticmapreduce:DescribeJobFlows", "elasticmapreduce:ListInstanceFleets", "elasticmapreduce:RunJobFlow", "elasticmapreduce:SetTerminationProtection", "elasticmapreduce:TerminateJobFlows", "elasticmapreduce:DescribeCluster"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:elasticmapreduce:*:*:cluster/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"cloudformation.amazonaws.com"}}}}, policy.Statement{Sid: "AirflowEnvironmentActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"airflow:CreateEnvironment", "airflow:DeleteEnvironment", "airflow:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"false"}}}}, policy.Statement{Sid: "AirflowEnvironmentActionsWithoutRestrictions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"airflow:GetEnvironment"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AirflowS3BucketActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetEncryptionConfiguration"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AirflowVpcEndpointActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateVpcEndpoint"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:vpc-endpoint/*", "arn:aws:ec2:*:*:vpc/*", "arn:aws:ec2:*:*:subnet/*", "arn:aws:ec2:*:*:security-group/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AirflowNetworkInterfaceActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateNetworkInterface"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:subnet/*", "arn:aws:ec2:*:*:network-interface/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AirflowKmsCreateGrant", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:CreateGrant"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"kms:EncryptionContextKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"airflow.*.amazonaws.com"}}}}, policy.Statement{Sid: "AirflowKmsDescribeKey", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:DescribeKey"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "IamRolePermissionsForSageMakerStudioQueryExecutionRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:GetRole", "iam:CreateRole", "iam:DetachRolePolicy", "iam:DeleteRolePolicy", "iam:AttachRolePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/SageMakerStudioQueryExecutionRole"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PermissionsBoundary": policy.Value{"arn:aws:iam::aws:policy/SageMakerStudioProjectUserRolePermissionsBoundary"}}}}, policy.Statement{Sid: "IamTagRolePermissionsForSageMakerStudioQueryExecutionRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:TagRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/SageMakerStudioQueryExecutionRole"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"CreatedForUseWithSageMakerStudio", "SageMakerStudioQueryExecutionRole"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}}}
