// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_SageMakerStudioProjectUserRolePolicy = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "CommonUserCodeCommitPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"codecommit:BatchGetCommits", "codecommit:BatchGetPullRequests", "codecommit:BatchGetRepositories", "codecommit:BatchDescribeMergeConflicts", "codecommit:CreateBranch", "codecommit:CreateCommit", "codecommit:CreatePullRequest", "codecommit:DeleteBranch", "codecommit:DeleteFile", "codecommit:DescribeMergeConflicts", "codecommit:DescribePullRequestEvents", "codecommit:GetBlob", "codecommit:GetBranch", "codecommit:GetComment", "codecommit:GetCommentReactions", "codecommit:GetCommentsForComparedCommit", "codecommit:GetCommentsForPullRequest", "codecommit:GetCommit", "codecommit:GetCommitHistory", "codecommit:GetCommitsFromMergeBase", "codecommit:GetDifferences", "codecommit:GetFile", "codecommit:GetFolder", "codecommit:GetMergeCommit", "codecommit:GetMergeConflicts", "codecommit:GetMergeOptions", "codecommit:GetObjectIdentifier", "codecommit:GetPullRequest", "codecommit:GetPullRequestApprovalStates", "codecommit:GetPullRequestOverrideState", "codecommit:GetReferences", "codecommit:GetRepository", "codecommit:GetRepositoryTriggers", "codecommit:GetTree", "codecommit:GetUploadArchiveStatus", "codecommit:GitPull", "codecommit:GitPush", "codecommit:ListAssociatedApprovalRuleTemplatesForRepository", "codecommit:ListBranches", "codecommit:ListFileCommitHistory", "codecommit:ListPullRequests", "codecommit:ListTagsForResource", "codecommit:MergeBranchesByFastForward", "codecommit:MergeBranchesBySquash", "codecommit:MergeBranchesByThreeWay", "codecommit:MergePullRequestByFastForward", "codecommit:MergePullRequestBySquash", "codecommit:MergePullRequestByThreeWay", "codecommit:UpdateComment", "codecommit:UpdateDefaultBranch", "codecommit:UpdatePullRequestApprovalRuleContent", "codecommit:UpdatePullRequestApprovalState", "codecommit:UpdatePullRequestDescription", "codecommit:UpdatePullRequestStatus", "codecommit:UpdatePullRequestTitle", "codecommit:UpdateRepositoryDescription", "codecommit:PostCommentForComparedCommit", "codecommit:PostCommentForPullRequest", "codecommit:PostCommentReply", "codecommit:PutCommentReaction", "codecommit:PutFile"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "AllowCodeWhispererGenerateRecommendations", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"codewhisperer:GenerateRecommendations"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AllowGlueCreateEni", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateNetworkInterface"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:network-interface/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:TagKeys": policy.Value{"true"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "glue:RoleAssumedBy": policy.Value{"glue.amazonaws.com"}}}}, policy.Statement{Sid: "AllowGlueCreateEniOnSecurityGroup", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateNetworkInterface"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:security-group/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}, "glue:RoleAssumedBy": policy.Value{"glue.amazonaws.com"}}}}, policy.Statement{Sid: "AllowGlueCreateEniOnSubnet", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateNetworkInterface"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:subnet/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "glue:RoleAssumedBy": policy.Value{"glue.amazonaws.com"}}}}, policy.Statement{Sid: "AllowManageGlueEni", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:DeleteNetworkInterface", "ec2:AttachNetworkInterface"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:network-interface/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"aws:ResourceTag/aws-glue-service-resource": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "glue:RoleAssumedBy": policy.Value{"glue.amazonaws.com"}}}}, policy.Statement{Sid: "AllowAttachGlueEniOnInstance", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:AttachNetworkInterface"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:instance/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"glue:RoleAssumedBy": policy.Value{"glue.amazonaws.com"}}, "StringNotEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AllowDescribeGlueEni", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:DescribeNetworkInterfaces"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"glue:RoleAssumedBy": policy.Value{"glue.amazonaws.com"}}}}, policy.Statement{Sid: "FederatedDataConnectionGlueSecret", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:DescribeSecret", "secretsmanager:GetSecretValue"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}, "glue:RoleAssumedBy": policy.Value{"glue.amazonaws.com"}}}}, policy.Statement{Sid: "GlueKernelPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:DescribeVpcEndpoints", "ec2:DescribeSubnets", "ec2:DescribeRouteTables", "ec2:DescribeSecurityGroups", "glue:ListSessions", "ec2:DescribeVpcs"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueCreateAndTagPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateSession", "glue:CreateBlueprint", "glue:CreateJob", "glue:CreateDataQualityRuleset", "glue:CreateWorkflow", "glue:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:session/*", "arn:aws:glue:*:*:blueprint/*", "arn:aws:glue:*:*:job/*", "arn:aws:glue:*:*:dataQualityRuleset/*", "arn:aws:glue:*:*:workflow/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "ProjectUserTag*"}}, "Null": map[string]policy.Value{"aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableGlueWorkloadsPermissions": policy.Value{"true"}, "aws:RequestTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "GlueTagSessionPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:TagResource", "glue:UntagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:session/*", "arn:aws:glue:*:*:blueprint/*", "arn:aws:glue:*:*:job/*", "arn:aws:glue:*:*:dataQualityRuleset/*", "arn:aws:glue:*:*:workflow/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"ProjectUserTag*"}}, "ForAllValues:StringNotLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*"}}, "StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableGlueWorkloadsPermissions": policy.Value{"true"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "GluePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CancelStatement", "glue:GetSession", "glue:ListStatements", "glue:DeleteSession", "glue:RunStatement", "glue:GetStatement", "glue:StopSession", "glue:GetDashboardUrl", "glue:NotifyEvent", "glue:StartBlueprintRun", "glue:PutWorkflowRunProperties", "glue:DeleteJob", "glue:DeleteWorkflow", "glue:DeleteBlueprint", "glue:UpdateWorkflow", "glue:UpdateJob", "glue:StartWorkflowRun", "glue:ResumeWorkflowRun", "glue:UpdateBlueprint", "glue:BatchStopJobRun", "glue:StopWorkflowRun", "glue:StartJobRun", "glue:CancelDataQualityRuleRecommendationRun", "glue:CancelDataQualityRulesetEvaluationRun", "glue:DeleteDataQualityRuleset", "glue:GetDataQualityModel", "glue:GetDataQualityModelResult", "glue:GetDataQualityResult", "glue:GetDataQualityRuleRecommendationRun", "glue:GetDataQualityRuleset", "glue:GetDataQualityRulesetEvaluationRun", "glue:ListDataQualityResults", "glue:ListDataQualityRuleRecommendationRuns", "glue:ListDataQualityRulesetEvaluationRuns", "glue:ListDataQualityRulesets", "glue:PublishDataQuality", "glue:PutDataQualityProfileAnnotation", "glue:PutDataQualityStatisticAnnotation", "glue:StartDataQualityRuleRecommendationRun", "glue:StartDataQualityRulesetEvaluationRun", "glue:UpdateDataQualityRuleset"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:session/*", "arn:aws:glue:*:*:blueprint/*", "arn:aws:glue:*:*:job/*", "arn:aws:glue:*:*:dataQualityRuleset/*", "arn:aws:glue:*:*:workflow/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableGlueWorkloadsPermissions": policy.Value{"true"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "GlueVisualETLPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetGeneratedCode"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueCompletionsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:StartCompletion", "glue:GetCompletion"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:completion/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "EC2TagsPermissionsForGlue", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:DeleteTags", "ec2:CreateTags"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:network-interface/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"aws-glue-*"}}, "Null": map[string]policy.Value{"aws:TagKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "glue:RoleAssumedBy": policy.Value{"glue.amazonaws.com"}}}}, policy.Statement{Sid: "AirflowActionsForTaggedEnvironments", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"airflow:GetEnvironment", "airflow:UpdateEnvironment"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "AirflowListEnvironments", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"airflow:ListEnvironments"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AirflowUiApiAccess", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"airflow:CreateWebLoginToken", "airflow:InvokeRestApi"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:airflow:*:*:role/DataZoneMWAAEnv-${aws:PrincipalTag/AmazonDataZoneDomain}-${aws:PrincipalTag/AmazonDataZoneProject}-${aws:PrincipalTag/AmazonDataZoneScopeName}/User"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AirflowCloudwatchLogsActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:CreateLogStream", "logs:CreateLogGroup", "logs:PutLogEvents", "logs:GetLogEvents", "logs:GetLogRecord", "logs:GetLogGroupFields", "logs:GetQueryResults"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:logs:*:*:log-group:airflow-DataZoneMWAAEnv-${aws:PrincipalTag/AmazonDataZoneDomain}-${aws:PrincipalTag/AmazonDataZoneProject}-${aws:PrincipalTag/AmazonDataZoneScopeName}-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AirflowCloudwatchActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudwatch:PutMetricData"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringLike": map[string]policy.Value{"cloudwatch:namespace": policy.Value{"AmazonMWAA"}}}}, policy.Statement{Sid: "AirflowS3GetAccountPublicAccessBlock", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetAccountPublicAccessBlock"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AirflowSqsActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sqs:ChangeMessageVisibility", "sqs:DeleteMessage", "sqs:GetQueueAttributes", "sqs:GetQueueUrl", "sqs:ReceiveMessage", "sqs:SendMessage"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sqs:*:*:airflow-celery-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringNotEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AirflowS3BucketActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetEncryptionConfiguration"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::${aws:PrincipalTag/DomainBucketName}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "DataLakeS3BucketActions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetBucketLocation"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "DataLakeCrossAccountS3Permissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetObject*", "s3:ListMultipartUploadParts", "s3:ListBucket"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringNotEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "DataLakeCrossAccountKMSPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:ListGrants", "kms:GetPublicKey", "kms:DescribeKey"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"s3.*.amazonaws.com"}}, "StringNotEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "DataLakeCrossAccountDecryptKMSPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:Decrypt"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAnyValue:StringEquals": map[string]policy.Value{"kms:EncryptionContextKeys": policy.Value{"aws:s3:arn"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"s3.*.amazonaws.com"}}, "StringNotEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ListDomainS3BucketPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:ListBucket", "s3:ListBucketVersions"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::${aws:PrincipalTag/DomainBucketName}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringLike": map[string]policy.Value{"s3:prefix": policy.Value{"${aws:PrincipalTag/AmazonDataZoneDomain}/${aws:PrincipalTag/AmazonDataZoneProject}", "${aws:PrincipalTag/AmazonDataZoneDomain}/${aws:PrincipalTag/AmazonDataZoneProject}/*"}}, "StringNotEquals": map[string]policy.Value{"aws:PrincipalTag/AmazonDataZoneDomain": policy.Value{""}, "aws:PrincipalTag/AmazonDataZoneProject": policy.Value{""}, "aws:PrincipalTag/DomainBucketName": policy.Value{""}}}}, policy.Statement{Sid: "AirflowListDomainS3BucketPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:ListBucket"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::${aws:PrincipalTag/DomainBucketName}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringNotEquals": map[string]policy.Value{"aws:PrincipalTag/DomainBucketName": policy.Value{""}}}}, policy.Statement{Sid: "ListDomainBucketFromAthenaFederatedCatalog", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:ListBucket"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::${aws:PrincipalTag/DomainBucketName}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ArnEquals": map[string]policy.Value{"lambda:SourceFunctionArn": policy.Value{"arn:aws:lambda:*:*:function:athenafederatedcatalog_*"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AccessDomainS3BucketPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetObject*", "s3:PutObject", "s3:PutObjectRetention", "s3:RestoreObject", "s3:ReplicateObject", "s3:DeleteObject", "s3:DeleteObjectVersion", "s3:ListMultipartUploadParts", "s3:AbortMultipartUpload"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::${aws:PrincipalTag/DomainBucketName}/${aws:PrincipalTag/AmazonDataZoneDomain}/${aws:PrincipalTag/AmazonDataZoneProject}/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringNotEquals": map[string]policy.Value{"aws:PrincipalTag/AmazonDataZoneDomain": policy.Value{""}, "aws:PrincipalTag/AmazonDataZoneProject": policy.Value{""}, "aws:PrincipalTag/DomainBucketName": policy.Value{""}}}}, policy.Statement{Sid: "TagS3ObjectPermissionsForBedrockEvaluation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:PutObjectTagging"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::${aws:PrincipalTag/DomainBucketName}/${aws:PrincipalTag/AmazonDataZoneDomain}/${aws:PrincipalTag/AmazonDataZoneProject}/genAI/assets/evaluations/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringEquals": map[string]policy.Value{"s3:RequestObjectTagKeys": policy.Value{"BasicValidationStatus", "ContainsReferenceResponseForAllPrompts"}}, "StringEquals": map[string]policy.Value{"s3:RequestObjectTag/BasicValidationStatus": policy.Value{"valid", "invalid"}, "s3:RequestObjectTag/ContainsReferenceResponseForAllPrompts": policy.Value{"true", "false"}}, "StringNotEquals": map[string]policy.Value{"aws:PrincipalTag/AmazonDataZoneDomain": policy.Value{""}, "aws:PrincipalTag/AmazonDataZoneProject": policy.Value{""}, "aws:PrincipalTag/DomainBucketName": policy.Value{""}}}}, policy.Statement{Sid: "AccessDomainS3BucketKmsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:GenerateDataKey", "kms:Decrypt"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/${aws:PrincipalTag/KmsKeyId}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ArnLike": map[string]policy.Value{"kms:EncryptionContext:aws:s3:arn": policy.Value{"arn:aws:s3:::${aws:PrincipalTag/DomainBucketName}", "arn:aws:s3:::${aws:PrincipalTag/DomainBucketName}/*"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"s3.*.amazonaws.com"}}}}, policy.Statement{Sid: "ListLogGroupsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:DescribeLogGroups"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "ProjectLogGroupPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:DescribeLogStreams", "logs:StartQuery", "logs:GetLogEvents", "logs:GetLogRecord", "logs:GetLogGroupFields", "logs:GetQueryResults", "logs:PutLogEvents", "logs:CreateLogStream", "logs:FilterLogEvents"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:logs:*:*:log-group:${aws:PrincipalTag/LogGroupName}", "arn:aws:logs:*:*:log-group:${aws:PrincipalTag/LogGroupName}:log-stream:*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "CloudWatchStopQuery", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:StopQuery"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "DataLakeEC2Permissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:AuthorizeSecurityGroupEgress", "ec2:AuthorizeSecurityGroupIngress", "ec2:RevokeSecurityGroupEgress", "ec2:RevokeSecurityGroupIngress"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "DataLakeAthenaPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"athena:TerminateSession", "athena:CreatePreparedStatement", "athena:StopCalculationExecution", "athena:StartQueryExecution", "athena:UpdatePreparedStatement", "athena:BatchGetNamedQuery", "athena:BatchGetPreparedStatement", "athena:BatchGetQueryExecution", "athena:UpdateNotebook", "athena:DeleteNotebook", "athena:DeletePreparedStatement", "athena:UpdateNotebookMetadata", "athena:DeleteNamedQuery", "athena:GetCalculationExecution", "athena:GetCalculationExecutionCode", "athena:GetCalculationExecutionStatus", "athena:GetNamedQuery", "athena:GetNotebookMetadata", "athena:GetPreparedStatement", "athena:GetQueryExecution", "athena:GetQueryResults", "athena:GetQueryResultsStream", "athena:GetQueryRuntimeStatistics", "athena:GetSession", "athena:GetSessionStatus", "athena:GetWorkGroup", "athena:UpdateNamedQuery", "athena:CreateNamedQuery", "athena:ExportNotebook", "athena:StopQueryExecution", "athena:StartCalculationExecution", "athena:StartSession", "athena:CreatePresignedNotebookUrl", "athena:CreateNotebook", "athena:ImportNotebook", "athena:ListQueryExecutions", "athena:ListTagsForResource", "athena:ListNamedQueries", "athena:ListPreparedStatements"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "DefaultAthenaDataCatalogPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"athena:GetDatabase", "athena:GetDataCatalog", "athena:GetTableMetadata", "athena:ListDatabases", "athena:ListTableMetadata"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:athena:*:*:datacatalog/AwsDataCatalog", "arn:aws:athena:*:*:datacatalog/awsdatacatalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AthenaListPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"athena:ListDataCatalogs", "athena:ListEngineVersions", "athena:ListWorkGroups"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "DataZoneUserPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"datazone:CreateConnection", "datazone:DeleteConnection", "datazone:GetConnection", "datazone:GetDomain", "datazone:GetDomainExecutionRoleCredentials", "datazone:GetEnvironment", "datazone:GetEnvironmentBlueprintConfiguration", "datazone:GetProject", "datazone:GetUserProfile", "datazone:ListConnections", "datazone:ListEnvironments", "datazone:ListEnvironmentBlueprints", "datazone:ListProjects", "datazone:UpdateConnection"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:datazone:*:*:domain/${aws:PrincipalTag/AmazonDataZoneDomain}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueGetDefaultDatabase", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/default"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueListDatabasesOnNoDatabases", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetDatabases"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueFileUploadPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetClassifier", "glue:GetClassifiers", "glue:UseGlueStudio"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueProjectConnectionPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:PassConnection", "glue:GetConnection", "glue:GetConnections"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "GlueGetConnectionOnlyOnCatalog", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetConnection", "glue:GetConnections"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueDatalakePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateTable", "glue:DeleteTable", "glue:BatchDeleteTable", "glue:UpdateTable", "glue:BatchCreatePartition", "glue:CreatePartition", "glue:DeletePartition", "glue:BatchDeletePartition", "glue:UpdatePartition", "glue:BatchGetPartition", "glue:BatchGetTableOptimizer", "glue:GetCatalogImportStatus", "glue:GetColumnStatisticsForPartition", "glue:GetColumnStatisticsForTable", "glue:GetColumnStatisticsTaskRun", "glue:GetColumnStatisticsTaskRuns", "glue:GetDatabase", "glue:GetDatabases", "glue:GetPartition", "glue:GetPartitionIndexes", "glue:GetPartitions", "glue:GetTable", "glue:GetTableOptimizer", "glue:GetTableVersion", "glue:GetTableVersions", "glue:GetTables", "glue:SearchTables", "glue:ListTableOptimizerRuns", "glue:CreatePartitionIndex", "glue:BatchUpdatePartition", "glue:DeleteTableVersion", "glue:DeleteColumnStatisticsForPartition", "glue:DeleteColumnStatisticsForTable", "glue:DeletePartitionIndex", "glue:UpdateColumnStatisticsForPartition", "glue:UpdateColumnStatisticsForTable", "glue:BatchDeleteTableVersion", "glue:GetCatalogs", "glue:GetCatalog"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"glue:LakeFormationPermissions": policy.Value{"Enabled"}}}}, policy.Statement{Sid: "GlueCrawlerPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:ListCrawls"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:crawler/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueGlobalTempDatabasePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateDatabase", "glue:DeleteDatabase", "glue:GetDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:database/global_temp", "arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueDefaultCatalogsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetCatalog", "glue:UpdateCatalog"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"glue:LakeFormationPermissions": policy.Value{"Enabled"}}}}, policy.Statement{Sid: "GlueNonDefaultCatalogsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetCatalog", "glue:UpdateCatalog"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}, "glue:LakeFormationPermissions": policy.Value{"Enabled"}}}}, policy.Statement{Sid: "GlueCatalogDatabasePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateDatabase", "glue:DeleteDatabase", "glue:GetDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:catalog/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "LakeFormationPermissionForDataLakeAccess", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lakeformation:GetDataAccess"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "IAMListRoles", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:ListRoles"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "IAMGetRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:GetRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AllowAssumeAccessRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sts:AssumeRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringNotEquals": map[string]policy.Value{"aws:PrincipalTag/AmazonDataZoneProject": policy.Value{""}}}}, policy.Statement{Sid: "SetSourceIdentityForAssumeAccessRole", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sts:SetSourceIdentity"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringLike": map[string]policy.Value{"sts:SourceIdentity": policy.Value{"${aws:PrincipalTag/datazone:userId}"}}}}, policy.Statement{Sid: "FederatedDataConnectionPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetConnection", "glue:GetConnections", "glue:GetTags"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "UnRestrictedAccessForGlueEntities", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:ListConnectionTypes", "glue:DescribeConnectionType"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "GlueEntitiesAccessForFederatedDatabase", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:ListEntities", "glue:DescribeEntity", "glue:GetEntityRecords"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AllowPassRoleOnProjectRoles", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/${aws:PrincipalTag/RoleName}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "iam:PassedToService": policy.Value{"sagemaker.amazonaws.com", "glue.amazonaws.com", "airflow.amazonaws.com", "emr-serverless.amazonaws.com"}}}}, policy.Statement{Sid: "SQLWorkBenchActionsWithoutResourceType", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sqlworkbench:PutTab", "sqlworkbench:DeleteTab", "sqlworkbench:DriverExecute", "sqlworkbench:GetUserInfo", "sqlworkbench:ListTabs", "sqlworkbench:GetAutocompletionMetadata", "sqlworkbench:GetAutocompletionResource", "sqlworkbench:PassAccountSettings", "sqlworkbench:ListQueryExecutionHistory", "sqlworkbench:GetQueryExecutionHistory", "sqlworkbench:CreateConnection", "sqlworkbench:PutQCustomContext", "sqlworkbench:GetQCustomContext", "sqlworkbench:DeleteQCustomContext", "sqlworkbench:GetQSqlRecommendations", "sqlworkbench:GetQSqlPromptQuotas"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "RedshiftDataActionsIAMSessionRestriction", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-data:DescribeStatement", "redshift-data:GetStatementResult", "redshift-data:CancelStatement", "redshift-data:ListStatements"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"redshift-data:statement-owner-iam-userid": policy.Value{"${aws:userid}"}}}}, policy.Statement{Sid: "RedshiftDataActionsForResources", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-data:BatchExecuteStatement", "redshift-data:ExecuteStatement", "redshift-data:DescribeTable", "redshift-data:ListDatabases", "redshift-data:ListSchemas", "redshift-data:ListTables"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "AllowAccessExistingRedshiftCompute", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:GetWorkgroup", "redshift-serverless:GetNamespace", "redshift-serverless:ListTagsForResource", "redshift-serverless:GetCredentials", "redshift:DescribeTags", "redshift:GetClusterCredentialsWithIAM", "redshift-data:BatchExecuteStatement", "redshift-data:ExecuteStatement", "redshift-data:DescribeTable", "redshift-data:ListDatabases", "redshift-data:ListSchemas", "redshift-data:ListTables"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/for-use-with-all-datazone-projects": policy.Value{"true"}}}}, policy.Statement{Sid: "RedshiftWithoutResourceType", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:ListNamespaces", "redshift-serverless:ListWorkgroups", "redshift:DescribeClusters"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "RedshiftServerlessWorkgroupWithResourceType", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:GetWorkgroup", "redshift-serverless:ListTagsForResource", "redshift-serverless:GetNamespace", "redshift:DescribeTags"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "RedshiftExistingComputeConnectToCatalog", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift:GetClusterCredentialsWithIAM"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift:*:*:dbname:*/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Bool": map[string]policy.Value{"aws:ViaAWSService": policy.Value{"true"}}}}, policy.Statement{Sid: "AllowListSecrets", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:ListSecrets"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "RedshiftServerlessGetCredentialsOnlyForDbUser", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:GetCredentials", "redshift:GetClusterCredentialsWithIAM"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}, "StringLike": map[string]policy.Value{"aws:PrincipalTag/RedshiftDbUser": policy.Value{"user-${aws:PrincipalTag/datazone:userId}*", "user-project@${aws:PrincipalTag/AmazonDataZoneProject}", "user-*@*"}}}}, policy.Statement{Sid: "RedshiftDataActionsForManagedWorkgroup", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-data:BatchExecuteStatement", "redshift-data:ExecuteStatement", "redshift-data:DescribeStatement", "redshift-data:GetStatementResult", "redshift-data:CancelStatement", "redshift-data:GetStagingBucketLocation", "redshift-serverless:GetManagedWorkgroup"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringLike": map[string]policy.Value{"redshift-data:glue-catalog-arn": policy.Value{"arn:aws:glue:*:*:catalog/*"}}}}, policy.Statement{Sid: "RedshifServerlessCredentialsForManagedWorkgroup", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"redshift-serverless:GetCredentials"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:redshift-serverless:*:*:workgroup/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Bool": map[string]policy.Value{"aws:ViaAWSService": policy.Value{"true"}}, "ForAnyValue:StringEquals": map[string]policy.Value{"aws:CalledVia": policy.Value{"redshift-data.amazonaws.com"}}}}, policy.Statement{Sid: "AllowTagGetResources", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"tag:GetResources"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaLast": policy.Value{"sqlworkbench.amazonaws.com"}}}}, policy.Statement{Sid: "AllowGetSecretForRedShift", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:GetSecretValue"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:secretsmanager:*:*:secret:*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "CloudWatchMetricsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudwatch:GetMetricData", "cloudwatch:GetMetricStatistics"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "AmazonQChatPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"q:StartConversation", "q:SendMessage"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "EMRClusterWithDataZoneTags", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"elasticmapreduce:DescribeCluster", "elasticmapreduce:ListInstances", "elasticmapreduce:ListInstanceFleets", "elasticmapreduce:ListInstanceGroups", "elasticmapreduce:ListBootstrapActions", "elasticmapreduce:TerminateJobFlows", "elasticmapreduce:GetManagedScalingPolicy", "elasticmapreduce:GetOnClusterAppUIPresignedURL"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:elasticmapreduce:*:*:cluster/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "EMRClusterInfoPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"elasticmapreduce:ListReleaseLabels", "elasticmapreduce:ListSupportedInstanceTypes", "elasticmapreduce:ListClusters", "pricing:GetProducts"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "EMRGetClusterSessionCredentials", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"elasticmapreduce:GetClusterSessionCredentials"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:elasticmapreduce:*:*:cluster/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ArnLike": map[string]policy.Value{"elasticmapreduce:ExecutionRoleArn": policy.Value{"arn:aws:iam::*:role/${aws:PrincipalTag/RoleName}"}}, "StringEquals": map[string]policy.Value{"aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "KmsWithEncryptPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:CreateGrant", "kms:ReEncryptFrom", "kms:ReEncryptTo", "kms:Decrypt", "kms:Encrypt", "kms:GenerateDataKey", "kms:GenerateDataKeyWithoutPlaintext"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/${aws:PrincipalTag/KmsKeyId}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"kms:EncryptionContextKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"sqs.*.amazonaws.com", "sagemaker.*.amazonaws.com", "bedrock.*.amazonaws.com", "s3.*.amazonaws.com"}}}}, policy.Statement{Sid: "KmsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:CreateGrant", "kms:ReEncryptFrom", "kms:ReEncryptTo", "kms:Decrypt", "kms:GenerateDataKey", "kms:GenerateDataKeyWithoutPlaintext"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/${aws:PrincipalTag/KmsKeyId}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"kms:EncryptionContextKeys": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"emr-serverless.*.amazonaws.com", "redshift.*.amazonaws.com"}}}}, policy.Statement{Sid: "KmsManagementPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:ListGrants", "kms:RevokeGrant", "kms:DescribeKey"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/${aws:PrincipalTag/KmsKeyId}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"sqs.*.amazonaws.com", "sagemaker.*.amazonaws.com", "emr-serverless.*.amazonaws.com", "s3.*.amazonaws.com", "redshift.*.amazonaws.com"}}}}, policy.Statement{Sid: "AwsOwnedKmsKeyPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:CreateGrant", "kms:Decrypt", "kms:Encrypt", "kms:GenerateDataKey", "kms:GenerateDataKeyWithoutPlaintext"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"kms:EncryptionContextKeys": policy.Value{"false"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"s3.*.amazonaws.com", "sqs.*.amazonaws.com", "sagemaker.*.amazonaws.com"}}, "StringNotEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AwsOwnedKmsManagementPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:DescribeKey"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"sqs.*.amazonaws.com", "sagemaker.*.amazonaws.com"}}, "StringNotEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ListKMSPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:ListAliases"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "EC2PermissionsForNotebookExecution", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:DescribeInstanceTypes"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "InvokeBedrockModelPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:InvokeModel", "bedrock:InvokeModelWithResponseStream"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:bedrock:*::foundation-model/*", "arn:aws:bedrock:*:*:custom-model/*", "arn:aws:bedrock:*:*:provisioned-model/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"bedrock:InferenceProfileArn": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}}}}, policy.Statement{Sid: "InvokeBedrockModelAppInferenceProfilePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:GetInferenceProfile", "bedrock:InvokeModel", "bedrock:InvokeModelWithResponseStream"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:bedrock:*:*:application-inference-profile/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "AccessBedrockResourcePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:InvokeAgent", "bedrock:Retrieve", "bedrock:ListIngestionJobs", "bedrock:StartIngestionJob", "bedrock:GetIngestionJob", "bedrock:ApplyGuardrail", "bedrock:ListPrompts", "bedrock:GetPrompt", "bedrock:CreatePrompt", "bedrock:DeletePrompt", "bedrock:CreatePromptVersion", "bedrock:InvokeFlow", "bedrock:GetEvaluationJob", "bedrock:CreateEvaluationJob", "bedrock:StopEvaluationJob", "bedrock:BatchDeleteEvaluationJob", "bedrock:ListTagsForResource", "bedrock:CreateAgentAlias", "bedrock:ListAgentAliases", "bedrock:GetAgentVersion", "bedrock:ListAgentVersions", "bedrock:DeleteAgentVersion", "bedrock:DeleteAgentAlias", "bedrock:GetAgentAlias", "bedrock:UpdateAgentAlias"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "CreateEvaluationJobForFoundationModelPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:CreateEvaluationJob"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:bedrock:*::foundation-model/*", "arn:aws:bedrock:*:*:custom-model/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "InvokeBedrockInlineAgentPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:InvokeInlineAgent"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}}}}, policy.Statement{Sid: "BedrockRetrieveAndGeneratePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:RetrieveAndGenerate"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}}}}, policy.Statement{Sid: "ListBedrockEvaluationJobPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:ListEvaluationJobs"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}}}}, policy.Statement{Sid: "PassRoleToBedrockEvaluation", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonBedrockEvaluationRole-${aws:PrincipalTag/AmazonDataZoneProject}-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "iam:PassedToService": policy.Value{"bedrock.amazonaws.com"}}}}, policy.Statement{Sid: "TagBedrockResourcePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"bedrock:TagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAllValues:StringLike": map[string]policy.Value{"aws:TagKeys": policy.Value{"AmazonDataZone*", "AmazonBedrockManaged", "ProjectUserTag*"}}, "StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "aws:RequestTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "BedrockKmsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:GenerateDataKey", "kms:Decrypt"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/${aws:PrincipalTag/KmsKeyId}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"Null": map[string]policy.Value{"kms:EncryptionContext:aws:bedrock:arn": policy.Value{"false"}}, "StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"bedrock.*.amazonaws.com"}}}}, policy.Statement{Sid: "AccessSecretPermissionsForAmazonBedrockIDE", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"secretsmanager:DescribeSecret", "secretsmanager:PutSecretValue"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:secretsmanager:*:*:secret:amazon-bedrock-ide/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "AccessSecretKmsPermissionsForAmazonBedrockIDE", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:GenerateDataKey", "kms:Decrypt"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:kms:*:*:key/${aws:PrincipalTag/KmsKeyId}"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ArnLike": map[string]policy.Value{"kms:EncryptionContext:SecretARN": policy.Value{"arn:aws:secretsmanager:*:*:secret:amazon-bedrock-ide/*"}}, "StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringLike": map[string]policy.Value{"kms:ViaService": policy.Value{"secretsmanager.*.amazonaws.com"}}}}, policy.Statement{Sid: "InvokeFunctionPermissionsForAmazonBedrockIDE", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:InvokeFunction"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:amazon-bedrock-ide-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:CalledViaFirst": policy.Value{"bedrock.amazonaws.com"}, "aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "GetDataZoneEnvironmentCloudFormationStackPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"cloudformation:GetTemplate", "cloudformation:DescribeStacks"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:cloudformation:*:*:stack/DataZone-Env-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:PrincipalTag/EnableAmazonBedrockIDEPermissions": policy.Value{"true"}, "aws:ResourceTag/AmazonDataZoneProject": policy.Value{"${aws:PrincipalTag/AmazonDataZoneProject}"}}}}, policy.Statement{Sid: "GetGlueUserDefinedFuncLakeFormationPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetUserDefinedFunction", "glue:GetUserDefinedFunctions"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:catalog/*", "arn:aws:glue:*:*:database/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}, "glue:LakeFormationPermissions": policy.Value{"Enabled"}}}}, policy.Statement{Sid: "GetGlueUserDefinedFuncPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetUserDefinedFunction", "glue:GetUserDefinedFunctions"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:userDefinedFunction/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}}}
