// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_SecurityLakeResourceManagementServiceRolePolicy = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "ReadEventBridgeRules", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"events:ListRules"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageSecurityLakeEventRules", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"events:PutRule"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:events:*:*:rule/AmazonSecurityLake-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageSecurityLakeLambdaConfigurations", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:GetEventSourceMapping", "lambda:GetFunction", "lambda:PutFunctionConcurrency", "lambda:GetProvisionedConcurrencyConfig", "lambda:GetFunctionConcurrency", "lambda:GetRuntimeManagementConfig", "lambda:PutProvisionedConcurrencyConfig", "lambda:PublishVersion", "lambda:DeleteFunctionConcurrency", "lambda:DeleteEventSourceMapping", "lambda:GetAlias", "lambda:GetPolicy", "lambda:GetFunctionConfiguration", "lambda:UpdateFunctionConfiguration"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:SecurityLake_Glue_Partition_Updater_Lambda*", "arn:aws:lambda:*:*:function:AmazonSecurityLakeMetastoreManager-*-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AllowListLambdaEventSourceMappings", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:ListEventSourceMappings"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AllowUpdateLambdaEventSourceMapping", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:UpdateEventSourceMapping"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}, "StringLike": map[string]policy.Value{"lambda:FunctionArn": policy.Value{"arn:aws:lambda:*:*:function:AmazonSecurityLakeMetastoreManager-*-*"}}}}, policy.Statement{Sid: "AllowUpdateLambdaConfigs", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lambda:UpdateFunctionConfiguration"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:lambda:*:*:function:AmazonSecurityLakeMetastoreManager-*-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageSecurityLakeGlueResources", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreatePartition", "glue:BatchCreatePartition", "glue:GetTable", "glue:GetTables", "glue:UpdateTable", "glue:GetDatabase"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:table/amazon_security_lake_glue_db*/*", "arn:aws:glue:*:*:database/amazon_security_lake_glue_db*", "arn:aws:glue:*:*:catalog"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AllowDataLakeConfigurationManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:ListBucket", "s3:PutObject", "s3:GetObjectAttributes", "s3:GetBucketNotification", "s3:PutBucketNotification", "s3:GetLifecycleConfiguration", "s3:PutLifecycleConfiguration", "s3:GetEncryptionConfiguration", "s3:GetReplicationConfiguration"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::aws-security-data-lake*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AllowMetaDataCompactionAndManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:GetObject", "s3:DeleteObject", "s3:RestoreObject"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::aws-security-data-lake*/metadata/*.avro", "arn:aws:s3:::aws-security-data-lake*/metadata/*.metadata.json"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ReadSecurityLakeLambdaLogs", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"logs:DescribeLogStreams", "logs:StartQuery", "logs:GetLogEvents", "logs:GetQueryResults", "logs:GetLogRecord"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:logs:*:*:log-group:/aws/lambda/AmazonSecurityLakeMetastoreManager-*-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "ManageSecurityLakeSQSQueue", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"sqs:StartMessageMoveTask", "sqs:DeleteMessage", "sqs:GetQueueUrl", "sqs:ListDeadLetterSourceQueues", "sqs:ChangeMessageVisibility", "sqs:ListMessageMoveTasks", "sqs:ReceiveMessage", "sqs:SendMessage", "sqs:GetQueueAttributes", "sqs:SetQueueAttributes"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:sqs:*:*:SecurityLake_*", "arn:aws:sqs:*:*:AmazonSecurityLakeManager-*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "AllowDataLakeManagement", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lakeformation:GetDataLakeSettings", "lakeformation:ListPermissions"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}}}
