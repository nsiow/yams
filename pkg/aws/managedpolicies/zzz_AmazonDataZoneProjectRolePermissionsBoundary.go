// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_AmazonDataZoneProjectRolePermissionsBoundary = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:List*", "s3:Get*", "s3:DeleteObjectVersion", "s3:RestoreObject", "s3:ReplicateObject", "s3:PutObject", "s3:AbortMultipartUpload", "s3:CreateBucket", "s3:PutBucketPublicAccessBlock", "s3:PutObjectRetention", "s3:DeleteObject"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:s3:::datazone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"StringEquals": map[string]policy.ConditionValue{"aws:ResourceAccount": "${aws:PrincipalAccount}"}}}, policy.Statement{Sid: "", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"s3:List*", "s3:Get*", "kms:List*", "kms:Get*", "kms:Describe*", "kms:Decrypt"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"StringNotEquals": map[string]policy.ConditionValue{"aws:ResourceAccount": "${aws:PrincipalAccount}"}}}, policy.Statement{Sid: "", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:Describe*", "ec2:CreateNetworkInterface", "ec2:DeleteNetworkInterface", "logs:*", "athena:TerminateSession", "athena:CreatePreparedStatement", "athena:StopCalculationExecution", "athena:StartQueryExecution", "athena:UpdatePreparedStatement", "athena:BatchGet*", "athena:List*", "athena:UpdateNotebook", "athena:DeleteNotebook", "athena:DeletePreparedStatement", "athena:UpdateNotebookMetadata", "athena:DeleteNamedQuery", "athena:Get*", "athena:UpdateNamedQuery", "athena:CreateNamedQuery", "athena:ExportNotebook", "athena:StopQueryExecution", "athena:StartCalculationExecution", "athena:StartSession", "athena:CreatePresignedNotebookUrl", "athena:CreateNotebook", "athena:ImportNotebook", "organizations:DescribeOrganization", "organizations:DescribeAccount", "lakeformation:GetDataAccess", "lakeformation:BatchGrantPermissions", "lakeformation:GrantPermissions", "lakeformation:GetDataLakeSettings", "lakeformation:PutDataLakeSettings", "lakeformation:BatchRevokePermissions", "lakeformation:GetResourceLFTags", "lakeformation:ListPermissions", "ram:CreateResourceShare", "ram:UpdateResourceShare", "ram:DeleteResourceShare", "ram:AssociateResourceShare", "ram:DisassociateResourceShare", "ram:AcceptResourceShareInvitation", "ram:Get*", "ram:List*", "redshift:DescribeClusters", "redshift:JoinGroup", "redshift:CreateClusterUser", "redshift:GetClusterCredentials", "redshift-data:*", "redshift:AuthorizeDataShare", "redshift:DescribeDataShares", "redshift:AssociateDataShareConsumer", "tag:GetResources", "iam:ListRoles", "iam:ListUsers", "iam:ListGroups", "iam:ListRolePolicies", "iam:GetRole", "iam:GetRolePolicy", "glue:CreateTable", "glue:BatchCreatePartition", "glue:CreatePartition", "glue:CreatePartitionIndex", "glue:CreateDataQualityRuleset", "glue:CreateBlueprint", "glue:CreateJob", "glue:CreateConnection", "glue:CreateCrawler", "glue:CreateWorkflow", "sqlworkbench:*", "datazone:*"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue(nil)}, policy.Statement{Sid: "", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ec2:CreateTags", "ec2:DeleteTags"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ec2:*:*:network-interface/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"ForAllValues:StringEquals": map[string]policy.ConditionValue{"aws:TagKeys": []interface{}{"aws-glue-service-resource"}}}}, policy.Statement{Sid: "", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:List*", "kms:Get*", "kms:Describe*", "kms:Decrypt", "kms:Encrypt", "kms:ReEncrypt*", "kms:Verify", "kms:Sign", "kms:GenerateDataKey", "glue:*"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue{"Null": map[string]policy.ConditionValue{"aws:ResourceTag/datazone:projectId": "false"}}}, policy.Statement{Sid: "", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/datazone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue(nil)}, policy.Statement{Sid: "", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:BatchGet*", "glue:SearchTables", "glue:List*", "glue:Get*", "glue:CreateDatabase", "glue:UpdateDatabase", "glue:DeleteTable", "glue:BatchDeleteTable", "glue:UpdateTable", "glue:DeletePartition", "glue:BatchDeletePartition", "glue:PutResourcePolicy", "glue:BatchUpdatePartition", "glue:DeleteTableVersion", "glue:DeleteColumnStatisticsForPartition", "glue:DeleteColumnStatisticsForTable", "glue:DeletePartitionIndex", "glue:UpdateColumnStatisticsForPartition", "glue:UpdateColumnStatisticsForTable", "glue:BatchDeleteTableVersion", "glue:UpdatePartition", "glue:NotifyEvent", "glue:DeleteResourcePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue(nil)}, policy.Statement{Sid: "", Effect: "Deny", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value(nil), NotAction: policy.Value{"s3:List*", "s3:Get*", "s3:Describe*", "s3:DeleteObjectVersion", "s3:RestoreObject", "s3:ReplicateObject", "s3:PutObject", "s3:AbortMultipartUpload", "s3:CreateBucket", "s3:PutBucketPublicAccessBlock", "s3:PutObjectRetention", "s3:DeleteObject", "kms:List*", "kms:Get*", "kms:Describe*", "kms:Decrypt", "kms:Encrypt", "kms:ReEncrypt*", "kms:Verify", "kms:Sign", "kms:GenerateDataKey", "ec2:Describe*", "ec2:CreateNetworkInterface", "ec2:DeleteNetworkInterface", "ec2:CreateTags", "ec2:DeleteTags", "logs:*", "athena:*", "glue:BatchGet*", "glue:Get*", "glue:SearchTables", "glue:List*", "glue:CreateDatabase", "glue:UpdateDatabase", "glue:CreateTable", "glue:DeleteTable", "glue:BatchDeleteTable", "glue:UpdateTable", "glue:BatchCreatePartition", "glue:CreatePartition", "glue:DeletePartition", "glue:BatchDeletePartition", "glue:PutResourcePolicy", "glue:CreatePartitionIndex", "glue:BatchUpdatePartition", "glue:DeleteTableVersion", "glue:DeleteColumnStatisticsForPartition", "glue:DeleteColumnStatisticsForTable", "glue:DeletePartitionIndex", "glue:UpdateColumnStatisticsForPartition", "glue:UpdateColumnStatisticsForTable", "glue:BatchDeleteTableVersion", "glue:UpdatePartition", "glue:NotifyEvent", "glue:StartBlueprintRun", "glue:PutWorkflowRunProperties", "glue:StopCrawler", "glue:DeleteJob", "glue:DeleteWorkflow", "glue:UpdateCrawler", "glue:DeleteBlueprint", "glue:UpdateWorkflow", "glue:StartCrawler", "glue:ResetJobBookmark", "glue:UpdateJob", "glue:StartWorkflowRun", "glue:StopCrawlerSchedule", "glue:ResumeWorkflowRun", "glue:DeleteCrawler", "glue:UpdateBlueprint", "glue:BatchStopJobRun", "glue:StopWorkflowRun", "glue:UpdateCrawlerSchedule", "glue:DeleteConnection", "glue:UpdateConnection", "glue:BatchDeleteConnection", "glue:StartCrawlerSchedule", "glue:StartJobRun", "glue:CreateWorkflow", "glue:*DataQuality*", "glue:CreateBlueprint", "glue:CreateJob", "glue:CreateConnection", "glue:CreateCrawler", "glue:DeleteResourcePolicy", "organizations:DescribeOrganization", "organizations:DescribeAccount", "lakeformation:GetDataAccess", "lakeformation:BatchGrantPermissions", "lakeformation:GrantPermissions", "lakeformation:GetDataLakeSettings", "lakeformation:PutDataLakeSettings", "lakeformation:BatchRevokePermissions", "lakeformation:GetResourceLFTags", "lakeformation:ListPermissions", "ram:*", "redshift:*", "redshift-data:*", "tag:GetResources", "iam:List*", "iam:GetRole", "iam:GetRolePolicy", "iam:PassRole", "sqlworkbench:*", "datazone:*"}, Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.ConditionValue(nil)}}}
