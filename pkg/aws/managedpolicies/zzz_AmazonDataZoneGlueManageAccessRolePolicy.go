// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_AmazonDataZoneGlueManageAccessRolePolicy = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "GlueDataQualityPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"glue:ListDataQualityResults", "glue:GetDataQualityResult"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:glue:*:*:dataQualityRuleset/*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"aws:ResourceAccount": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"${aws:PrincipalAccount}"}}}}}, policy.Statement{Sid: "GlueTableDatabasePermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"glue:CreateTable", "glue:DeleteTable", "glue:GetDatabases", "glue:GetTables"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:table/*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"aws:ResourceAccount": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"${aws:PrincipalAccount}"}}}}}, policy.Statement{Sid: "LakeformationResourceSharingPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"lakeformation:BatchGrantPermissions", "lakeformation:BatchRevokePermissions", "lakeformation:CreateLakeFormationOptIn", "lakeformation:DeleteLakeFormationOptIn", "lakeformation:GrantPermissions", "lakeformation:GetResourceLFTags", "lakeformation:ListLakeFormationOptIns", "lakeformation:ListPermissions", "lakeformation:RegisterResource", "lakeformation:RevokePermissions", "glue:GetDatabase", "glue:GetTable", "organizations:DescribeOrganization", "ram:GetResourceShareInvitations", "ram:ListResources"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "CrossAccountRAMResourceSharingPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"glue:DeleteResourcePolicy", "glue:PutResourcePolicy"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:table/*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"ram.amazonaws.com"}}}}}, policy.Statement{Sid: "CrossAccountLakeFormationResourceSharingPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"ram:CreateResourceShare"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"lakeformation.amazonaws.com"}}}, "StringEqualsIfExists": policy.Condition{"ram:RequestedResourceType": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"glue:Table", "glue:Database", "glue:Catalog"}}}}}, policy.Statement{Sid: "CrossAccountRAMResourceShareInvitationPermission", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"ram:AcceptResourceShareInvitation"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:ram:*:*:resource-share-invitation/*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "CrossAccountRAMResourceSharingViaLakeFormationPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"ram:AssociateResourceShare", "ram:DeleteResourceShare", "ram:DisassociateResourceShare", "ram:GetResourceShares", "ram:ListResourceSharePermissions", "ram:UpdateResourceShare"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"lakeformation.amazonaws.com"}}}, "StringLike": policy.Condition{"ram:ResourceShareName": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"LakeFormation*"}}}}}, policy.Statement{Sid: "CrossAccountRAMResourceSharingViaLakeFormationHybrid", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"ram:AssociateResourceSharePermission"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"lakeformation.amazonaws.com"}}}, "StringLike": policy.Condition{"ram:PermissionArn": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"arn:aws:ram::aws:permission/AWSRAMLFEnabled*"}}}}}, policy.Statement{Sid: "KMSDecryptPermission", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"kms:Decrypt"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"aws:ResourceTag/datazone:projectId": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"proj-all"}}}}}, policy.Statement{Sid: "GetRoleForDataZone", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:GetRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/AmazonDataZone*", "arn:aws:iam::*:role/service-role/AmazonDataZone*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "PassRoleForDataLocationRegistration", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Action{Value: policy.Value{"iam:PassRole"}}, NotAction: policy.Action{Value: policy.Value(nil)}, Resource: policy.Resource{Value: policy.Value{"arn:aws:iam::*:role/AmazonDataZone*", "arn:aws:iam::*:role/service-role/AmazonDataZone*"}}, NotResource: policy.Resource{Value: policy.Value(nil)}, Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"iam:PassedToService": policy.ConditionValue{bools: []bool(nil), numbers: []int(nil), strings: []string{"lakeformation.amazonaws.com"}}}}}}}
