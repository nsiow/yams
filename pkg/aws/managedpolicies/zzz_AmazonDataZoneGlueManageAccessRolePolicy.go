// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_AmazonDataZoneGlueManageAccessRolePolicy = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "GlueTagDatabasePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:TagResource", "glue:UntagResource"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAnyValue:StringLikeIfExists": map[string]policy.Value{"aws:TagKeys": policy.Value{"DataZoneDiscoverable_*"}}, "StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueDataQualityPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:ListDataQualityResults", "glue:GetDataQualityResult"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:dataQualityRuleset/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueCrawlerPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:ListCrawls"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:crawler/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueTableDatabasePermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:CreateTable", "glue:DeleteTable", "glue:GetDatabases", "glue:GetTables", "glue:SearchTables"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:catalog/*", "arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:table/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "GlueGetTagsPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:GetTags", "glue:GetCatalog"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:catalog/*", "arn:aws:glue:*:*:database/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceAccount": policy.Value{"${aws:PrincipalAccount}"}}}}, policy.Statement{Sid: "LakeformationResourceSharingPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lakeformation:BatchGrantPermissions", "lakeformation:BatchRevokePermissions", "lakeformation:CreateDataCellsFilter", "lakeformation:CreateLakeFormationOptIn", "lakeformation:DeleteDataCellsFilter", "lakeformation:DeleteLakeFormationOptIn", "lakeformation:GrantPermissions", "lakeformation:GetDataCellsFilter", "lakeformation:GetResourceLFTags", "lakeformation:ListDataCellsFilter", "lakeformation:ListLakeFormationOptIns", "lakeformation:ListPermissions", "lakeformation:RegisterResource", "lakeformation:RevokePermissions", "lakeformation:UpdateDataCellsFilter", "glue:GetDatabase", "glue:GetTable", "organizations:DescribeOrganization", "ram:GetResourceShareInvitations", "ram:ListResources"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "LakeformationResourceFederatedSharingPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"lakeformation:GetDataAccess"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAnyValue:StringEquals": map[string]policy.Value{"aws:CalledVia": policy.Value{"glue.amazonaws.com", "lakeformation.amazonaws.com"}}, "Null": map[string]policy.Value{"lakeformation:GlueARN": policy.Value{"true"}}}}, policy.Statement{Sid: "CrossAccountRAMResourceSharingPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"glue:DeleteResourcePolicy", "glue:PutResourcePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:catalog/*", "arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:table/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAnyValue:StringEquals": map[string]policy.Value{"aws:CalledVia": policy.Value{"ram.amazonaws.com"}}}}, policy.Statement{Sid: "CrossAccountLakeFormationResourceSharingPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ram:CreateResourceShare"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAnyValue:StringEquals": map[string]policy.Value{"aws:CalledVia": policy.Value{"lakeformation.amazonaws.com"}}, "StringEqualsIfExists": map[string]policy.Value{"ram:RequestedResourceType": policy.Value{"glue:Table", "glue:Database", "glue:Catalog"}}}}, policy.Statement{Sid: "CrossAccountRAMResourceShareInvitationPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ram:AcceptResourceShareInvitation"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ram:*:*:resource-share-invitation/*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "CrossAccountRAMResourceSharingViaLakeFormationPermissions", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ram:AssociateResourceShare", "ram:DeleteResourceShare", "ram:DisassociateResourceShare", "ram:GetResourceShares", "ram:ListResourceSharePermissions", "ram:UpdateResourceShare"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ForAnyValue:StringEquals": map[string]policy.Value{"aws:CalledVia": policy.Value{"lakeformation.amazonaws.com"}}, "StringLike": map[string]policy.Value{"ram:ResourceShareName": policy.Value{"LakeFormation*"}}}}, policy.Statement{Sid: "CrossAccountRAMResourceSharingViaLakeFormationHybrid", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"ram:AssociateResourceSharePermission"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"ArnLike": map[string]policy.Value{"ram:PermissionArn": policy.Value{"arn:aws:ram::aws:permission/AWSRAMLFEnabled*"}}, "ForAnyValue:StringEquals": map[string]policy.Value{"aws:CalledVia": policy.Value{"lakeformation.amazonaws.com"}}}}, policy.Statement{Sid: "KMSDecryptPermission", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"kms:Decrypt"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"aws:ResourceTag/datazone:projectId": policy.Value{"proj-all"}}}}, policy.Statement{Sid: "GetRoleForDataZone", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:GetRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonDataZone*", "arn:aws:iam::*:role/service-role/AmazonDataZone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value(nil)}, policy.Statement{Sid: "PassRoleForDataLocationRegistration", Effect: "Allow", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonDataZone*", "arn:aws:iam::*:role/service-role/AmazonDataZone*"}, NotResource: policy.Value(nil), Condition: map[string]map[string]policy.Value{"StringEquals": map[string]policy.Value{"iam:PassedToService": policy.Value{"lakeformation.amazonaws.com"}}}}}}
