// This file was automatically generated by build tooling; do not edit!

package managedpolicies

import (
	"github.com/nsiow/yams/pkg/policy"
)

var AWS_MANAGED_POLICY_AmazonDataZoneGlueManageAccessRolePolicy = policy.Policy{Version: "2012-10-17", Id: "", Statement: policy.StatementBlock{policy.Statement{Sid: "GlueDataQualityPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"glue:ListDataQualityResults", "glue:GetDataQualityResult"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:dataQualityRuleset/*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"aws:ResourceAccount": "${aws:PrincipalAccount}"}}}, policy.Statement{Sid: "GlueTableDatabasePermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"glue:CreateTable", "glue:DeleteTable", "glue:GetDatabases", "glue:GetTables"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:table/*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"aws:ResourceAccount": "${aws:PrincipalAccount}"}}}, policy.Statement{Sid: "LakeformationResourceSharingPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"lakeformation:BatchGrantPermissions", "lakeformation:BatchRevokePermissions", "lakeformation:CreateLakeFormationOptIn", "lakeformation:DeleteLakeFormationOptIn", "lakeformation:GrantPermissions", "lakeformation:GetResourceLFTags", "lakeformation:ListLakeFormationOptIns", "lakeformation:ListPermissions", "lakeformation:RegisterResource", "lakeformation:RevokePermissions", "glue:GetDatabase", "glue:GetTable", "organizations:DescribeOrganization", "ram:GetResourceShareInvitations", "ram:ListResources"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "CrossAccountRAMResourceSharingPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"glue:DeleteResourcePolicy", "glue:PutResourcePolicy"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:glue:*:*:catalog", "arn:aws:glue:*:*:database/*", "arn:aws:glue:*:*:table/*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": []interface{}{"ram.amazonaws.com"}}}}, policy.Statement{Sid: "CrossAccountLakeFormationResourceSharingPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"ram:CreateResourceShare"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": []interface{}{"lakeformation.amazonaws.com"}}, "StringEqualsIfExists": policy.Condition{"ram:RequestedResourceType": []interface{}{"glue:Table", "glue:Database", "glue:Catalog"}}}}, policy.Statement{Sid: "CrossAccountRAMResourceShareInvitationPermission", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"ram:AcceptResourceShareInvitation"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:ram:*:*:resource-share-invitation/*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "CrossAccountRAMResourceSharingViaLakeFormationPermissions", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"ram:AssociateResourceShare", "ram:DeleteResourceShare", "ram:DisassociateResourceShare", "ram:GetResourceShares", "ram:ListResourceSharePermissions", "ram:UpdateResourceShare"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": []interface{}{"lakeformation.amazonaws.com"}}, "StringLike": policy.Condition{"ram:ResourceShareName": []interface{}{"LakeFormation*"}}}}, policy.Statement{Sid: "CrossAccountRAMResourceSharingViaLakeFormationHybrid", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"ram:AssociateResourceSharePermission"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock{"ForAnyValue:StringEquals": policy.Condition{"aws:CalledVia": []interface{}{"lakeformation.amazonaws.com"}}, "StringLike": policy.Condition{"ram:PermissionArn": "arn:aws:ram::aws:permission/AWSRAMLFEnabled*"}}}, policy.Statement{Sid: "KMSDecryptPermission", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"kms:Decrypt"}, NotAction: policy.Value(nil), Resource: policy.Value{"*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"aws:ResourceTag/datazone:projectId": "proj-all"}}}, policy.Statement{Sid: "GetRoleForDataZone", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"iam:GetRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonDataZone*", "arn:aws:iam::*:role/service-role/AmazonDataZone*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock(nil)}, policy.Statement{Sid: "PassRoleForDataLocationRegistration", Principal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, NotPrincipal: policy.Principal{AWS: policy.Value(nil), Federated: policy.Value(nil), Service: policy.Value(nil), CanonicalUser: policy.Value(nil)}, Effect: "Allow", Action: policy.Value{"iam:PassRole"}, NotAction: policy.Value(nil), Resource: policy.Value{"arn:aws:iam::*:role/AmazonDataZone*", "arn:aws:iam::*:role/service-role/AmazonDataZone*"}, NotResource: policy.Value(nil), Condition: policy.ConditionBlock{"StringEquals": policy.Condition{"iam:PassedToService": []interface{}{"lakeformation.amazonaws.com"}}}}}}
